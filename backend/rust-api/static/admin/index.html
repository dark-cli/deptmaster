<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debt Tracker - Admin Panel</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #FFFBFE; /* Material 3 light background */
            color: #1C1B1F; /* Material 3 on background */
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: #1C1B1F; /* Material 3 dark background */
            color: #E6E1E5; /* Material 3 on background */
        }

        .header {
            background: #6750A4; /* Material 3 light primary */
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.dark-mode .header {
            background: #6750A4; /* Keep primary color in dark mode too */
        }

        .header h1 {
            font-size: 1.5rem;
            margin: 0;
        }

        .header .dark-mode-toggle {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s;
        }

        .header .dark-mode-toggle:hover {
            background: rgba(255,255,255,0.3);
        }

        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #FFFBFE; /* Material 3 light surface */
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode .stat-card {
            background: #1C1B1F; /* Material 3 dark surface */
        }

        .stat-card h3 {
            font-size: 0.9rem;
            color: #79747E; /* Material 3 light outline */
            margin-bottom: 0.5rem;
        }

        body.dark-mode .stat-card h3 {
            color: #938F99; /* Material 3 dark outline */
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: #6750A4; /* Material 3 light primary */
        }

        /* Event detail modal */
        .event-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .event-modal.active {
            display: flex;
        }

        .event-modal-content {
            background: #FFFBFE;
            border-radius: 12px;
            padding: 2rem;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            position: relative;
        }

        body.dark-mode .event-modal-content {
            background: #1C1B1F;
            color: #E6E1E5;
        }

        .event-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #E7E0EC;
        }

        body.dark-mode .event-modal-header {
            border-bottom-color: #49454F;
        }

        .event-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6750A4;
            padding: 0.5rem;
            line-height: 1;
        }

        .event-modal-close:hover {
            opacity: 0.7;
        }

        .event-modal-field {
            margin-bottom: 1rem;
        }

        .event-modal-field-label {
            font-weight: 600;
            color: #6750A4;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .event-modal-field-value {
            font-size: 1rem;
            color: #1C1B1F;
            word-break: break-word;
        }

        body.dark-mode .event-modal-field-value {
            color: #E6E1E5;
        }

        .event-row {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .event-row:hover {
            background-color: rgba(103, 80, 164, 0.05);
        }

        body.dark-mode .event-row:hover {
            background-color: rgba(103, 80, 164, 0.15);
        }

        body.dark-mode .stat-card .value {
            color: #D0BCFF; /* Material 3 dark primary */
        }

        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #E7E0EC; /* Material 3 light surface variant */
        }

        body.dark-mode .tabs {
            border-bottom-color: #49454F; /* Material 3 dark surface variant */
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1rem;
            color: #79747E; /* Material 3 light outline */
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: color 0.3s;
        }

        body.dark-mode .tab {
            color: #938F99; /* Material 3 dark outline */
        }

        .tab.active {
            color: #6750A4; /* Material 3 light primary */
            border-bottom-color: #6750A4;
        }

        body.dark-mode .tab.active {
            color: #D0BCFF; /* Material 3 dark primary */
            border-bottom-color: #D0BCFF;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .table-container {
            background: #FFFBFE; /* Material 3 light surface */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: background-color 0.3s;
        }

        body.dark-mode .table-container {
            background: #1C1B1F; /* Material 3 dark surface */
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid #E7E0EC; /* Material 3 light surface variant */
        }

        body.dark-mode th,
        body.dark-mode td {
            border-bottom-color: #49454F; /* Material 3 dark surface variant */
        }

        th {
            background: #E7E0EC; /* Material 3 light surface variant */
            font-weight: 600;
            color: #1C1B1F; /* Material 3 on surface */
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode th {
            background: #49454F; /* Material 3 dark surface variant */
            color: #E6E1E5; /* Material 3 on surface */
        }

        tr:hover {
            background: #E7E0EC; /* Material 3 light surface variant */
            transition: background-color 0.2s;
        }

        body.dark-mode tr:hover {
            background: #49454F; /* Material 3 dark surface variant */
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge.success {
            background: rgba(22, 163, 74, 0.1); /* Material 3 light success with opacity */
            color: #16A34A; /* Material 3 light success */
        }

        body.dark-mode .badge.success {
            background: rgba(74, 222, 128, 0.2); /* Material 3 dark success with opacity */
            color: #4ADE80; /* Material 3 dark success */
        }

        .badge.warning {
            background: rgba(245, 158, 11, 0.1); /* Material 3 light warning with opacity */
            color: #F59E0B; /* Material 3 light warning */
        }

        body.dark-mode .badge.warning {
            background: rgba(251, 191, 36, 0.2); /* Material 3 dark warning with opacity */
            color: #FBBF24; /* Material 3 dark warning */
        }

        .badge.error {
            background: rgba(186, 26, 26, 0.1); /* Material 3 light error with opacity */
            color: #BA1A1A; /* Material 3 light error */
        }

        body.dark-mode .badge.error {
            background: rgba(255, 180, 171, 0.2); /* Material 3 dark error with opacity */
            color: #FFB4AB; /* Material 3 dark error */
        }

        .refresh-btn {
            background: #6750A4; /* Material 3 light primary */
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin-bottom: 1rem;
            transition: background-color 0.3s;
        }

        .refresh-btn:hover {
            background: #4F378B; /* Material 3 light primary dark */
        }

        body.dark-mode .refresh-btn {
            background: #6750A4; /* Keep primary in dark mode */
        }

        body.dark-mode .refresh-btn:hover {
            background: #B69DF8; /* Material 3 dark primary dark */
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #79747E; /* Material 3 light outline */
        }

        body.dark-mode .loading {
            color: #938F99; /* Material 3 dark outline */
        }

        .error {
            background: rgba(186, 26, 26, 0.1); /* Material 3 light error with opacity */
            color: #BA1A1A; /* Material 3 light error */
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        body.dark-mode         .error {
            background: rgba(255, 180, 171, 0.2); /* Material 3 dark error with opacity */
            color: #FFB4AB; /* Material 3 dark error */
        }

        /* Dark mode styles for all form inputs and interactive elements */
        body.dark-mode .filter-section {
            background: #1C1B1F !important;
            border-bottom-color: #49454F !important;
        }

        body.dark-mode .form-input,
        body.dark-mode input[type="text"],
        body.dark-mode input[type="date"],
        body.dark-mode input[type="search"],
        body.dark-mode select {
            background: #1C1B1F !important;
            border-color: #49454F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode select option {
            background: #1C1B1F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .form-input::placeholder,
        body.dark-mode input::placeholder {
            color: #938F99 !important;
        }

        body.dark-mode label,
        body.dark-mode .form-label {
            color: #E6E1E5 !important;
        }

        body.dark-mode .pagination-section {
            background: #49454F !important;
            border-bottom-color: #49454F !important;
        }

        body.dark-mode .page-info {
            color: #E6E1E5 !important;
        }

        body.dark-mode .events-count {
            color: #938F99 !important;
        }

        body.dark-mode .btn-secondary {
            background: #625B71 !important;
        }

        body.dark-mode .btn-secondary:hover {
            background: #4A4458 !important;
        }

        body.dark-mode .btn-pagination {
            background: #6750A4 !important;
        }

        body.dark-mode .btn-pagination:hover {
            background: #B69DF8 !important;
        }

        body.dark-mode .btn-pagination:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        body.dark-mode .event-name {
            color: #938F99 !important;
        }

        body.dark-mode .user-id {
            color: #CAC4D0 !important;
        }

        body.dark-mode .comment-box {
            background: rgba(103, 80, 164, 0.2) !important;
            border-left-color: #D0BCFF !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .no-comment {
            color: #938F99 !important;
        }

        body.dark-mode .details-summary {
            color: #938F99 !important;
        }

        body.dark-mode .details-summary-link {
            color: #D0BCFF !important;
        }

        body.dark-mode .details-pre {
            background: #49454F !important;
            border-color: #49454F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .projection-info {
            background: #49454F !important;
            color: #E6E1E5 !important;
        }

        /* Code elements */
        code {
            background: #E7E0EC;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        body.dark-mode code {
            background: #49454F;
            color: #E6E1E5;
        }

        /* Username tag styling */
        .username-tag {
            display: inline-block;
            padding: 2px 6px;
            background-color: #E8E0EC;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 500;
            color: #6750A4;
            margin-right: 6px;
        }

        body.dark-mode .username-tag {
            background-color: rgba(208, 188, 255, 0.3); /* Light purple with opacity for better visibility */
            color: #D0BCFF; /* Light purple text - Material 3 dark primary light */
            border: 1px solid rgba(208, 188, 255, 0.5); /* Subtle border for definition */
        }

        .chart-container {
            background: #FFFBFE;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
            transition: background-color 0.3s;
        }

        body.dark-mode .chart-container {
            background: #1C1B1F;
        }

        .chart-container h2 {
            margin: 0 0 1rem 0;
            color: #1C1B1F;
            font-size: 1.25rem;
            transition: color 0.3s;
        }

        body.dark-mode .chart-container h2 {
            color: #E6E1E5;
        }

        .chart-container canvas {
            background: #FFFBFE;
            transition: background-color 0.3s;
        }

        body.dark-mode .chart-container canvas {
            background: #1C1B1F;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .chart-period-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .chart-period-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #E7E0EC;
            background: #FFFBFE;
            color: #1C1B1F;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        body.dark-mode .chart-period-btn {
            background: #1C1B1F;
            border-color: #49454F;
            color: #E6E1E5;
        }

        .chart-period-btn:hover {
            background: #E7E0EC;
        }

        body.dark-mode .chart-period-btn:hover {
            background: #49454F;
        }

        .chart-period-btn.active {
            background: #6750A4;
            color: white;
            border-color: #6750A4;
        }

        body.dark-mode .chart-period-btn.active {
            background: #6750A4;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Debt Tracker - Admin Panel</h1>
        <button id="darkModeToggle" class="dark-mode-toggle">
            üåô Dark Mode
        </button>
    </div>

    <div class="container">
        <button class="refresh-btn" onclick="loadData()">üîÑ Refresh Data</button>

        <div class="stats" id="stats">
            <div class="stat-card">
                <h3>Total Contacts</h3>
                <div class="value" id="totalContacts">-</div>
            </div>
            <div class="stat-card">
                <h3>Total Transactions</h3>
                <div class="value" id="totalTransactions">-</div>
            </div>
            <div class="stat-card">
                <h3>Total Debt</h3>
                <div class="value" id="totalDebt">-</div>
            </div>
            <div class="stat-card">
                <h3>Pending Reminders</h3>
                <div class="value" id="pendingReminders">-</div>
            </div>
        </div>

        <!-- Debt Over Time Chart -->
        <div class="chart-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2>Total Debt Over Time</h2>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="chart-period-btn" onclick="setChartPeriod('day')" data-period="day">Day</button>
                    <button class="chart-period-btn" onclick="setChartPeriod('week')" data-period="week">Week</button>
                    <button class="chart-period-btn active" onclick="setChartPeriod('month')" data-period="month">Month</button>
                    <button class="chart-period-btn" onclick="setChartPeriod('year')" data-period="year">Year</button>
                </div>
            </div>
            <div style="position: relative; height: 400px;">
                <canvas id="debtChart"></canvas>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('events')">Events Log</button>
            <button class="tab" onclick="switchTab('contacts')">Contacts</button>
            <button class="tab" onclick="switchTab('transactions')">Transactions</button>
            <button class="tab" onclick="switchTab('projections')">Projections</button>
            <button class="tab" onclick="switchTab('users')">User Management</button>
        </div>

        <div id="events" class="tab-content active">
            <div class="table-container">
                <!-- Search and Filter Controls -->
                <div class="filter-section" style="padding: 1rem; background: #FFFBFE; border-bottom: 1px solid #E7E0EC;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">üîç Search</label>
                            <input type="text" id="eventSearch" placeholder="Search in comments, names, event types..." 
                                   class="form-input"
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;"
                                   onkeyup="debounceSearch()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Event Type</label>
                            <select id="eventTypeFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                                <option value="">All Event Types</option>
                                <optgroup label="Transaction Events">
                                    <option value="CREATED_TRANSACTION">CREATED_TRANSACTION</option>
                                    <option value="UPDATE_TRANSACTION">UPDATE_TRANSACTION</option>
                                    <option value="DELETE_TRANSACTION">DELETE_TRANSACTION</option>
                                </optgroup>
                                <optgroup label="Contact Events">
                                    <option value="CREATED_CONTACT">CREATED_CONTACT</option>
                                    <option value="UPDATE_CONTACT">UPDATE_CONTACT</option>
                                    <option value="DELETE_CONTACT">DELETE_CONTACT</option>
                                </optgroup>
                                <optgroup label="Other Events">
                                    <option value="UNDO">UNDO</option>
                                </optgroup>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Aggregate Type</label>
                            <select id="aggregateTypeFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                                <option value="">All</option>
                                <option value="contact">Contact</option>
                                <option value="transaction">Transaction</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date From</label>
                            <input type="date" id="dateFromFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date To</label>
                            <input type="date" id="dateToFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <button class="refresh-btn" onclick="applyFilters()" style="margin: 0;">üîç Apply Filters</button>
                        <button onclick="clearFilters()" class="btn-secondary" style="padding: 0.75rem 1.5rem; background: #625B71; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Clear Filters</button>
                        <button class="refresh-btn" onclick="loadEvents()" style="margin: 0; background: #4caf50;">üîÑ Refresh</button>
                        <span id="eventsCount" class="events-count" style="margin-left: auto; color: #79747E;"></span>
                    </div>
                </div>
                
                <!-- Pagination -->
                <div class="pagination-section" style="padding: 1rem; background: #E7E0EC; border-bottom: 1px solid #E7E0EC; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label class="form-label" style="margin-right: 0.5rem; color: #1C1B1F;">Page Size:</label>
                        <select id="pageSize" class="form-input" onchange="applyFilters()" style="padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;">
                            <option value="50">50</option>
                            <option value="100" selected>100</option>
                            <option value="200">200</option>
                            <option value="500">500</option>
                        </select>
                    </div>
                    <div>
                        <button onclick="previousPage()" id="prevBtn" class="btn-pagination" style="padding: 0.5rem 1rem; margin-right: 0.5rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">‚Üê Previous</button>
                        <span id="pageInfo" class="page-info" style="margin: 0 1rem; color: #1C1B1F;">Page 1</span>
                        <button onclick="nextPage()" id="nextBtn" class="btn-pagination" style="padding: 0.5rem 1rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Next ‚Üí</button>
                    </div>
                </div>
                
                <div class="loading" id="eventsLoading">Loading events...</div>
                <table id="eventsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Event Type</th>
                            <th>Contact Name</th>
                            <th>Amount</th>
                            <th>Debt</th>
                            <th>User</th>
                            <th>Comment</th>
                            <th>Details</th>
                        </tr>
                    </thead>
                    <tbody id="eventsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="contacts" class="tab-content">
            <div class="table-container">
                <div class="loading" id="contactsLoading">Loading contacts...</div>
                <table id="contactsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Username</th>
                            <th>Email</th>
                            <th>Phone</th>
                            <th>Balance</th>
                            <th>Created At</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="contactsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="transactions" class="tab-content">
            <div class="table-container">
                <!-- Search and Filter Controls -->
                <div class="filter-section" style="padding: 1rem; background: #FFFBFE; border-bottom: 1px solid #E7E0EC;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">üîç Search</label>
                            <input type="text" id="transactionSearch" placeholder="Search in contact names, descriptions..." 
                                   class="form-input"
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;"
                                   onkeyup="debounceTransactionSearch()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Type</label>
                            <select id="transactionTypeFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyTransactionFilters()">
                                <option value="">All Types</option>
                                <option value="money">Money</option>
                                <option value="item">Item</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Direction</label>
                            <select id="transactionDirectionFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyTransactionFilters()">
                                <option value="">All Directions</option>
                                <option value="lent">Lent</option>
                                <option value="owed">Owed</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date From</label>
                            <input type="date" id="transactionDateFromFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyTransactionFilters()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date To</label>
                            <input type="date" id="transactionDateToFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyTransactionFilters()">
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <button class="refresh-btn" onclick="applyTransactionFilters()" style="margin: 0;">üîç Apply Filters</button>
                        <button onclick="clearTransactionFilters()" class="btn-secondary" style="padding: 0.75rem 1.5rem; background: #625B71; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Clear Filters</button>
                        <button class="refresh-btn" onclick="loadTransactions()" style="margin: 0; background: #4caf50;">üîÑ Refresh</button>
                        <span id="transactionsCount" class="events-count" style="margin-left: auto; color: #79747E;"></span>
                    </div>
                </div>
                
                <!-- Pagination -->
                <div class="pagination-section" style="padding: 1rem; background: #E7E0EC; border-bottom: 1px solid #E7E0EC; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label class="form-label" style="margin-right: 0.5rem; color: #1C1B1F;">Page Size:</label>
                        <select id="transactionPageSize" class="form-input" onchange="applyTransactionFilters()" style="padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;">
                            <option value="50">50</option>
                            <option value="100" selected>100</option>
                            <option value="200">200</option>
                            <option value="500">500</option>
                        </select>
                    </div>
                    <div>
                        <button onclick="previousTransactionPage()" id="transactionPrevBtn" class="btn-pagination" style="padding: 0.5rem 1rem; margin-right: 0.5rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">‚Üê Previous</button>
                        <span id="transactionPageInfo" class="page-info" style="margin: 0 1rem; color: #1C1B1F;">Page 1</span>
                        <button onclick="nextTransactionPage()" id="transactionNextBtn" class="btn-pagination" style="padding: 0.5rem 1rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Next ‚Üí</button>
                    </div>
                </div>
                
                <div class="loading" id="transactionsLoading">Loading transactions...</div>
                <table id="transactionsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Contact</th>
                            <th>Amount</th>
                            <th>Direction</th>
                        </tr>
                    </thead>
                    <tbody id="transactionsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="projections" class="tab-content">
            <div class="table-container">
                <div class="loading" id="projectionsLoading">Loading projections...</div>
                <div id="projectionsContent" style="display: none; padding: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Projection Status</h3>
                    <div id="projectionsInfo"></div>
                </div>
            </div>
        </div>

        <div id="users" class="tab-content">
            <div class="table-container">
                <div style="padding: 1rem; background: #FFFBFE; border-bottom: 1px solid #E7E0EC; margin-bottom: 1rem;">
                    <button onclick="showCreateUserModal()" class="refresh-btn" style="margin: 0; background: #4caf50;">+ Create User</button>
                </div>
                <div class="loading" id="usersLoading">Loading users...</div>
                <table id="usersTable" style="display: none; width: 100%;">
                    <thead>
                        <tr>
                            <th>Email</th>
                            <th>Created At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="usersBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Event Detail Modal -->
    <div id="eventModal" class="event-modal" onclick="closeEventModal(event)">
        <div class="event-modal-content" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2>Event Details</h2>
                <button class="event-modal-close" onclick="closeEventModal()">&times;</button>
            </div>
            <div id="eventModalBody"></div>
        </div>
    </div>

    <!-- Event Detail Modal -->
    <div id="eventModal" class="event-modal" onclick="closeEventModal(event)">
        <div class="event-modal-content" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2>Event Details</h2>
                <button class="event-modal-close" onclick="closeEventModal()">&times;</button>
            </div>
            <div id="eventModalBody"></div>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="loginModal" class="event-modal" style="display: flex;">
        <div class="event-modal-content" onclick="event.stopPropagation()" style="max-width: 400px;">
            <div class="event-modal-header">
                <h2>Admin Login</h2>
            </div>
            <div style="padding: 1rem;">
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Email:</label>
                    <input type="email" id="loginEmail" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px;" placeholder="admin@debitum.local">
                </div>
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Password:</label>
                    <input type="password" id="loginPassword" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px;" placeholder="Enter password">
                </div>
                <button onclick="performLogin()" class="refresh-btn" style="width: 100%; margin: 0;">Login</button>
                <div id="loginError" style="color: #f44336; margin-top: 0.5rem; display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Load configuration (if exists) -->
    <script src="config.js" onerror="console.log('Using default config')"></script>
    <script>
        // Use config from config.js if available, otherwise use defaults
        const API_URL = window.ADMIN_CONFIG?.API_URL || window.location.origin + '/api';
        const WS_URL = window.ADMIN_CONFIG?.WS_URL || ((window.location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + window.location.host + '/ws');
        
        // Authentication
        // Logout function to clear all auth data
        function logout() {
            console.log('üîí Logging out user...');
            localStorage.removeItem('auth_token');
            localStorage.removeItem('user_id');
            localStorage.removeItem('username');
            document.getElementById('loginModal').style.display = 'flex';
            // Clear any displayed data
            document.getElementById('eventsBody').innerHTML = '';
            document.getElementById('contactsBody').innerHTML = '';
            document.getElementById('transactionsBody').innerHTML = '';
            document.getElementById('eventsCount').textContent = '';
            document.getElementById('contactsCount').textContent = '';
            document.getElementById('transactionsCount').textContent = '';
            // Stop any ongoing updates
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }

        function checkAuth() {
            const token = localStorage.getItem('auth_token');
            if (!token) {
                logout();
                return false;
            }
            document.getElementById('loginModal').style.display = 'none';
            return true;
        }

        // Validate token by making a test API call
        async function validateAuth() {
            const token = localStorage.getItem('auth_token');
            if (!token) {
                logout();
                return false;
            }

            try {
                // Try to fetch a lightweight endpoint to validate token
                const response = await authenticatedFetch(`${API_URL}/admin/events/latest`);
                if (response.status === 401) {
                    console.log('‚ö†Ô∏è Token validation failed - logging out');
                    logout();
                    return false;
                }
                return true;
            } catch (error) {
                // If it's an auth error, logout
                if (error.message.includes('Authentication')) {
                    console.log('‚ö†Ô∏è Authentication error - logging out');
                    logout();
                    return false;
                }
                // Other errors might be network issues, but we'll still try to proceed
                console.warn('‚ö†Ô∏è Token validation check failed:', error);
                return true; // Assume token is valid if it's not an auth error
            }
        }

        async function performLogin() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            if (!email || !password) {
                errorDiv.textContent = 'Please enter email and password';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const response = await fetch(`${API_URL}/auth/admin/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username: email, password })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Login failed');
                }

                const data = await response.json();
                localStorage.setItem('auth_token', data.token);
                localStorage.setItem('user_id', data.admin_id || data.user_id); // Support both field names
                localStorage.setItem('username', data.username);
                
                document.getElementById('loginModal').style.display = 'none';
                // Start WebSocket connection after successful login
                startSmartUpdates();
                loadData();
            } catch (error) {
                errorDiv.textContent = error.message;
                errorDiv.style.display = 'block';
            }
        }

        // Add Enter key support for login
        document.addEventListener('DOMContentLoaded', () => {
            const loginPassword = document.getElementById('loginPassword');
            if (loginPassword) {
                loginPassword.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        performLogin();
                    }
                });
            }
        });

        // Helper function to make authenticated API requests
        async function authenticatedFetch(url, options = {}) {
            const token = localStorage.getItem('auth_token');
            if (!token) {
                // No token, logout and show login modal
                logout();
                throw new Error('Authentication required');
            }
            const headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
            const response = await fetch(url, { ...options, headers });
            
            // If we get a 401, logout (clear token and show login modal)
            if (response.status === 401) {
                console.log('‚ö†Ô∏è Received 401 Unauthorized - logging out');
                logout();
                throw new Error('Authentication expired. Please login again.');
            }
            
            return response;
        }
        
        // Smart update state
        let lastEventId = null;
        let wsConnection = null;
        let pollingInterval = null;
        let isUpdating = false;
        let currentTotalDebt = null; // Store current total debt for fallback in events
        
        // Chart state
        let debtChart = null;
        let chartPeriod = 'month'; // Default to month
        let currentChartData = []; // Store chart data for click handler
        
        function setChartPeriod(period) {
            chartPeriod = period;
            // Update button states
            document.querySelectorAll('.chart-period-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-period') === period) {
                    btn.classList.add('active');
                }
            });
            loadDebtChart();
        }
        
        // Initialize chart period button state on page load
        function initializeChartPeriod() {
            setChartPeriod('month'); // Set default to month
        }
        
        // Helper functions to align dates to calendar boundaries
        function alignToDayStart(date) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }
        
        function alignToWeekStart(date) {
            const dayOfWeek = date.getDay(); // 0=Sunday, 6=Saturday
            const daysToSubtract = dayOfWeek === 0 ? 0 : dayOfWeek;
            const sunday = new Date(date);
            sunday.setDate(date.getDate() - daysToSubtract);
            return alignToDayStart(sunday);
        }
        
        function alignToMonthStart(date) {
            return new Date(date.getFullYear(), date.getMonth(), 1);
        }
        
        function alignToYearStart(date) {
            return new Date(date.getFullYear(), 0, 1);
        }
        
        async function loadDebtChart() {
            try {
                // Calculate date range based on period (rolling periods: last 24h, 7d, 30d, 365d)
                const now = new Date();
                let periodStart = new Date();
                
                switch (chartPeriod) {
                    case 'day':
                        // Last 24 hours, but align to day boundaries
                        periodStart = alignToDayStart(new Date(now.getTime() - (24 * 60 * 60 * 1000)));
                        break;
                    case 'week':
                        // Last 7 days, but align to week boundaries (Sunday to Sunday)
                        periodStart = alignToWeekStart(new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000)));
                        break;
                    case 'month':
                        // Last 30 days, but align to month boundaries
                        const monthStart = alignToMonthStart(new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000)));
                        const currentMonthStart = alignToMonthStart(now);
                        periodStart = monthStart < currentMonthStart ? monthStart : currentMonthStart;
                        break;
                    case 'year':
                        // Last 365 days, but align to year boundaries
                        const yearStart = alignToYearStart(new Date(now.getTime() - (365 * 24 * 60 * 60 * 1000)));
                        const currentYearStart = alignToYearStart(now);
                        periodStart = yearStart < currentYearStart ? yearStart : currentYearStart;
                        break;
                }
                
                // Fetch all events since period start
                const params = new URLSearchParams();
                params.append('date_from', periodStart.toISOString());
                params.append('limit', '10000'); // Get all events in range
                
                const response = await authenticatedFetch(`${API_URL}/admin/events?${params.toString()}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const events = await response.json();
                
                // Sort events by timestamp
                events.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                
                // Build raw event data: time and total_debt
                // Only include transaction events (CREATED, UPDATED, DELETED) - exclude contact events
                const rawEventData = [];
                
                for (const event of events) {
                    // Filter: only transaction events
                    if (event.aggregate_type !== 'transaction') {
                        continue; // Skip contact events
                    }
                    
                    const eventDataObj = event.event_data || {};
                    const totalDebt = eventDataObj.total_debt;
                    
                    if (totalDebt !== null && totalDebt !== undefined) {
                        const debt = Number(totalDebt);
                        if (!isNaN(debt) && isFinite(debt)) {
                            rawEventData.push({
                                timestamp: new Date(event.created_at).getTime(),
                                debt: debt,
                                event: event // Store full event for tooltip
                            });
                        }
                    }
                }
                
                // If no data points, use current total debt
                if (rawEventData.length === 0 && currentTotalDebt !== null) {
                    rawEventData.push({
                        timestamp: new Date().getTime(),
                        debt: currentTotalDebt
                    });
                }
                
                // Determine time scale configuration based on period
                let timeUnit = 'day';
                let timeStepSize = 1;
                let minorUnit = null;
                let minorStepSize = null;
                let displayFormats = {};
                let intervalMs = 0; // Interval size in milliseconds
                
                switch (chartPeriod) {
                    case 'day':
                        timeUnit = 'hour';
                        timeStepSize = 1;
                        minorUnit = 'minute';
                        minorStepSize = 15;
                        intervalMs = 60 * 60 * 1000; // 1 hour intervals
                        displayFormats = {
                            hour: 'HH:mm',
                            minute: 'mm'
                        };
                        break;
                    case 'week':
                        timeUnit = 'day';
                        timeStepSize = 1;
                        intervalMs = 24 * 60 * 60 * 1000; // 1 day intervals
                        displayFormats = {
                            day: 'EEE d'
                        };
                        break;
                    case 'month':
                        timeUnit = 'week';
                        timeStepSize = 1;
                        minorUnit = 'day';
                        minorStepSize = 1;
                        intervalMs = 24 * 60 * 60 * 1000; // 1 day intervals (average per day)
                        displayFormats = {
                            week: 'MMM d',
                            day: 'd'
                        };
                        break;
                    case 'year':
                        timeUnit = 'month';
                        timeStepSize = 1;
                        minorUnit = 'week';
                        minorStepSize = 1;
                        intervalMs = 7 * 24 * 60 * 60 * 1000; // 1 week intervals (average per week)
                        displayFormats = {
                            month: 'MMM yyyy',
                            week: 'w'
                        };
                        break;
                }
                
                // Set date range - always start from period start, even if no data
                const maxDate = now.getTime();
                const minDate = periodStart.getTime();
                
                // Calculate average debt for each time interval
                const chartData = [];
                const numIntervals = Math.ceil((maxDate - minDate) / intervalMs);
                
                for (let i = 0; i <= numIntervals; i++) {
                    // Calculate interval boundaries aligned to calendar units
                    let intervalStart, intervalEnd, intervalCenter;
                    
                    if ((chartPeriod === 'week' || chartPeriod === 'month') && intervalMs === 24 * 60 * 60 * 1000) {
                        // For day intervals in week/month views, align to day boundaries (00:00:00 to 23:59:59.999)
                        const baseDate = new Date(minDate);
                        const dayStart = alignToDayStart(new Date(baseDate.getTime() + (i * 24 * 60 * 60 * 1000)));
                        intervalStart = dayStart.getTime();
                        const dayEnd = new Date(dayStart);
                        dayEnd.setDate(dayEnd.getDate() + 1);
                        dayEnd.setMilliseconds(dayEnd.getMilliseconds() - 1);
                        intervalEnd = Math.min(dayEnd.getTime(), maxDate);
                        intervalCenter = intervalStart + ((intervalEnd - intervalStart) / 2);
                    } else if (chartPeriod === 'year' && intervalMs === 7 * 24 * 60 * 60 * 1000) {
                        // For week intervals in year view, align to week boundaries (Sunday to Saturday)
                        const baseDate = new Date(minDate);
                        const weekStart = alignToWeekStart(new Date(baseDate.getTime() + (i * 7 * 24 * 60 * 60 * 1000)));
                        intervalStart = weekStart.getTime();
                        const weekEnd = new Date(weekStart);
                        weekEnd.setDate(weekEnd.getDate() + 7);
                        weekEnd.setMilliseconds(weekEnd.getMilliseconds() - 1);
                        intervalEnd = Math.min(weekEnd.getTime(), maxDate);
                        intervalCenter = intervalStart + ((intervalEnd - intervalStart) / 2);
                    } else {
                        // For hour intervals or other cases, use millisecond-based calculation
                        intervalStart = minDate + (i * intervalMs);
                        intervalEnd = Math.min(intervalStart + intervalMs, maxDate);
                        intervalCenter = intervalStart + (intervalMs / 2);
                    }
                    
                    // Find all events in this interval - use proper boundaries (inclusive end for day boundaries)
                    const eventsInInterval = rawEventData.filter(evt => 
                        evt.timestamp >= intervalStart && evt.timestamp <= intervalEnd
                    );
                    
                    let avgDebt = null;
                    let intervalEvents = []; // Store all events in this interval for tooltip
                    let hasTransactions = false; // Track if this interval has actual transactions
                    
                    if (eventsInInterval.length > 0) {
                        // Calculate average debt for this interval
                        const sum = eventsInInterval.reduce((acc, evt) => acc + evt.debt, 0);
                        avgDebt = sum / eventsInInterval.length;
                        // Store all events in this interval for tooltip
                        intervalEvents = eventsInInterval.map(evt => evt.event).filter(e => e !== null);
                        hasTransactions = true; // This interval has transactions
                    } else {
                        // No events in this interval - find the closest event before this interval
                        const beforeEvents = rawEventData.filter(evt => evt.timestamp < intervalStart);
                        if (beforeEvents.length > 0) {
                            // Use the debt value from the most recent event before this interval
                            const closestBefore = beforeEvents[beforeEvents.length - 1];
                            avgDebt = closestBefore.debt;
                            // Don't store events - this interval has no transactions
                            intervalEvents = [];
                            hasTransactions = false;
                        } else if (rawEventData.length > 0) {
                            // Use the first event's debt if no events before
                            avgDebt = rawEventData[0].debt;
                            intervalEvents = [];
                            hasTransactions = false;
                        } else {
                            // No data at all
                            avgDebt = currentTotalDebt || 0;
                            intervalEvents = [];
                            hasTransactions = false;
                        }
                    }
                    
                    // Store label colors for tooltip (for per-transaction coloring)
                    const labelColors = [];
                    if (hasTransactions && intervalEvents.length > 0) {
                        // First label is average (default color)
                        labelColors.push(null); // null = use default
                        // Then each transaction gets its color
                        intervalEvents.forEach((event) => {
                            const eventData = event.event_data || {};
                            const isGave = eventData.direction === 'lent';
                            labelColors.push(isGave ? '#16A34A' : '#BA1A1A'); // Gave = green, Received = red
                        });
                    }
                    
                    chartData.push({
                        x: intervalCenter,
                        y: avgDebt,
                        events: intervalEvents, // Store all events in interval for tooltip
                        hasTransactions: hasTransactions, // Flag to show/hide point
                        intervalStart: intervalStart, // Store for click handler
                        intervalEnd: intervalEnd, // Store for click handler
                        labelColors: labelColors // Store colors for each label line
                    });
                }
                
                // Store chart data globally for click handler
                currentChartData = chartData;
                
                // Create or update chart
                const ctx = document.getElementById('debtChart');
                const isDark = document.body.classList.contains('dark-mode');
                
                const chartConfig = {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Total Debt (IQD)',
                            data: chartData,
                            borderColor: '#6750A4',
                            backgroundColor: 'rgba(103, 80, 164, 0.1)',
                            borderWidth: 2,
                            fill: false, // No fill - just line connecting actual events
                            tension: 0, // Straight lines (was 0.4 for curved)
                            pointRadius: function(context) {
                                // Hide points where no transactions occurred
                                return context.raw?.hasTransactions ? 4 : 0;
                            },
                            pointHoverRadius: function(context) {
                                // Only allow hover on points with transactions
                                return context.raw?.hasTransactions ? 6 : 0;
                            },
                            pointBackgroundColor: '#6750A4',
                            pointBorderColor: isDark ? '#1C1B1F' : '#FFFBFE',
                            pointBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: isDark ? '#E6E1E5' : '#1C1B1F',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                filter: function(tooltipItem) {
                                    // Hide tooltip completely for points without transactions
                                    return tooltipItem.raw?.hasTransactions === true;
                                },
                                backgroundColor: isDark ? '#49454F' : '#FFFBFE',
                                titleColor: isDark ? '#E6E1E5' : '#1C1B1F',
                                bodyColor: isDark ? '#E6E1E5' : '#1C1B1F',
                                borderColor: '#6750A4',
                                borderWidth: 1,
                                padding: 8,
                                titleFont: { size: 12, weight: '600' },
                                bodyFont: { size: 11 },
                                titleSpacing: 4,
                                bodySpacing: 3,
                                displayColors: false,
                                usePointStyle: false,
                                callbacks: {
                                    title: function(context) {
                                        // Safely access context array - check if it exists and has elements
                                        if (!context || !Array.isArray(context) || context.length === 0) {
                                            return null; // Hide tooltip if no context data
                                        }
                                        
                                        const point = context[0];
                                        if (!point || !point.raw) {
                                            return null; // Hide tooltip if point data is invalid
                                        }
                                        
                                        const hasTransactions = point.raw.hasTransactions || false;
                                        
                                        // Only show tooltip if there are transactions in this interval
                                        if (!hasTransactions) {
                                            return null; // Hide tooltip for intervals with no transactions
                                        }
                                        
                                        // Calculate interval size based on chart period
                                        let intervalSize = 0;
                                        switch (chartPeriod) {
                                            case 'day': intervalSize = 60 * 60 * 1000; break; // 1 hour
                                            case 'week': intervalSize = 24 * 60 * 60 * 1000; break; // 1 day
                                            case 'month': intervalSize = 24 * 60 * 60 * 1000; break; // 1 day
                                            case 'year': intervalSize = 7 * 24 * 60 * 60 * 1000; break; // 1 week
                                        }
                                        
                                        // Show interval time range
                                        const intervalStart = new Date(point.parsed.x - (intervalSize / 2));
                                        const intervalEnd = new Date(point.parsed.x + (intervalSize / 2));
                                        
                                        let title = intervalStart.toLocaleString('en-US', {
                                            month: 'short',
                                            day: 'numeric',
                                            hour: 'numeric',
                                            minute: '2-digit'
                                        });
                                        
                                        // Determine format based on interval size
                                        if (intervalSize <= 60 * 60 * 1000) {
                                            // Hour or smaller intervals - show time only for end
                                            title += ' - ' + intervalEnd.toLocaleTimeString('en-US', {
                                                hour: 'numeric',
                                                minute: '2-digit'
                                            });
                                        } else {
                                            // Day or larger intervals - show full date/time
                                            title += ' - ' + intervalEnd.toLocaleString('en-US', {
                                                month: 'short',
                                                day: 'numeric',
                                                hour: 'numeric',
                                                minute: '2-digit'
                                            });
                                        }
                                        
                                        return title;
                                    },
                                    label: function(context) {
                                        // Safely access context - check if it exists and has raw data
                                        if (!context || !context.raw) {
                                            return null; // Hide tooltip if context data is invalid
                                        }
                                        
                                        const point = context;
                                        const events = point.raw.events || [];
                                        const hasTransactions = point.raw.hasTransactions || false;
                                        
                                        // Only show tooltip if there are transactions in this interval
                                        if (!hasTransactions || events.length === 0) {
                                            return null; // Hide tooltip for intervals with no transactions
                                        }
                                        
                                        const debt = Math.round(context.parsed.y);
                                        const lines = [`Avg: ${debt.toLocaleString('en-US')} IQD ‚Ä¢ ${events.length} tx`];
                                        
                                        if (events.length > 0) {
                                            // Show up to 4 transactions in compact format
                                            const maxShow = 4;
                                            const eventsToShow = events.slice(0, maxShow);
                                            
                                            eventsToShow.forEach((event) => {
                                                const eventData = event.event_data || {};
                                                const date = new Date(event.created_at);
                                                const timeStr = date.toLocaleTimeString('en-US', {
                                                    hour: 'numeric',
                                                    minute: '2-digit'
                                                });
                                                
                                                let txLine = `${timeStr} `;
                                                
                                                if (eventData.amount !== null && eventData.amount !== undefined) {
                                                    const amount = Number(eventData.amount);
                                                    // Standardization: Received (owed) = -, Gave (lent) = +
                                                    const sign = eventData.direction === 'lent' ? '+' : '-';
                                                    const currency = eventData.currency || 'IQD';
                                                    txLine += `${sign}${Math.round(amount).toLocaleString('en-US')} ${currency}`;
                                                } else {
                                                    txLine += event.event_type;
                                                }
                                                
                                                const contactData = contactCache[eventData.contact_id]; if (contactData) {
                                                    txLine += ` ‚Ä¢ ${contactData?.name || "Unknown"}`;
                                                }
                                                
                                                lines.push(txLine);
                                            });
                                            
                                            if (events.length > maxShow) {
                                                lines.push(`+${events.length - maxShow} more`);
                                            }
                                        }
                                        
                                        return lines;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: timeUnit,
                                    stepSize: timeStepSize,
                                    displayFormats: displayFormats,
                                    tooltipFormat: 'PPpp'
                                },
                                min: minDate,
                                max: maxDate,
                                ticks: {
                                    color: isDark ? '#938F99' : '#79747E',
                                    maxRotation: 45,
                                    minRotation: 45,
                                    source: 'auto',
                                    autoSkip: true
                                },
                                grid: {
                                    color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                                    drawOnChartArea: true
                                },
                                ...(minorUnit && minorStepSize ? {
                                    minor: {
                                        unit: minorUnit,
                                        stepSize: minorStepSize,
                                        display: true
                                    },
                                    grid: {
                                        ...(isDark ? {
                                            color: 'rgba(255, 255, 255, 0.05)'
                                        } : {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }),
                                        drawOnChartArea: true,
                                        drawTicks: false
                                    }
                                } : {})
                            },
                            y: {
                                reverse: true, // Zero at bottom
                                ticks: {
                                    color: isDark ? '#938F99' : '#79747E',
                                    callback: function(value) {
                                        return Math.round(value).toLocaleString('en-US') + ' IQD';
                                    }
                                },
                                grid: {
                                    color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        onClick: function(event, elements) {
                            if (elements.length > 0) {
                                const element = elements[0];
                                const point = currentChartData[element.index];
                                
                                // Only filter if this point has transactions
                                if (point && point.hasTransactions) {
                                    // Format dates for input fields (YYYY-MM-DD)
                                    // Use aligned day boundaries for proper filtering
                                    const formatDate = (timestamp) => {
                                        const date = new Date(timestamp);
                                        // Align to start of day for proper filtering
                                        const dayStart = alignToDayStart(date);
                                        const year = dayStart.getFullYear();
                                        const month = String(dayStart.getMonth() + 1).padStart(2, '0');
                                        const day = String(dayStart.getDate()).padStart(2, '0');
                                        return `${year}-${month}-${day}`;
                                    };
                                    
                                    // Set filter dates using stored interval boundaries (aligned to day start)
                                    // For day intervals, use the day boundaries
                                    const intervalStartDate = alignToDayStart(new Date(point.intervalStart));
                                    const intervalEndDate = alignToDayStart(new Date(point.intervalEnd));
                                    
                                    document.getElementById('dateFromFilter').value = formatDate(intervalStartDate);
                                    // For end date, use the same day (inclusive) or next day (exclusive)
                                    // Since we want to include events on the end day, we use the end day itself
                                    document.getElementById('dateToFilter').value = formatDate(intervalEndDate);
                                    
                                    // Switch to Events tab if not already there
                                    switchTab('events');
                                    
                                    // Apply filters to show events in this time period
                                    applyFilters();
                                }
                            }
                        }
                    }
                };
                
                if (debtChart) {
                    // Destroy and recreate chart to ensure all colors update properly
                    debtChart.destroy();
                    debtChart = null;
                }
                
                // Create new chart with current dark mode state
                debtChart = new Chart(ctx, chartConfig);
            } catch (error) {
                console.error('Error loading debt chart:', error);
            }
        }

        async function loadData() {
            // Validate authentication first (makes a test API call)
            const isValid = await validateAuth();
            if (!isValid) {
                console.log('‚ö†Ô∏è Authentication invalid - user logged out, showing login modal');
                return;
            }
            
            // Double-check token exists
            if (!checkAuth()) {
                console.log('‚ö†Ô∏è No authentication token - showing login modal');
                return;
            }
            
            try {
                console.log('üîÑ Loading admin data...');
                // Load stats first to populate currentTotalDebt
                await loadStats();
                // Then load events (which will use currentTotalDebt as fallback)
                await Promise.all([
                    loadEvents(),
                    loadContacts(),
                    loadTransactions(),
                    loadProjections(),
                    loadDebtChart()
                ]);
                console.log('‚úÖ Admin data loaded successfully');
            } catch (error) {
                console.error('‚ùå Error loading admin data:', error);
                // Don't show alert for authentication errors - logout() already handled it
                if (!error.message.includes('Authentication') && !error.message.includes('expired')) {
                    alert('Error loading data: ' + error.message + '\n\nPlease check the browser console for details.');
                }
            }
        }

        async function loadStats() {
            try {
                const [contacts, transactions, totalDebtResponse] = await Promise.all([
                    authenticatedFetch(`${API_URL}/admin/contacts`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    }),
                    authenticatedFetch(`${API_URL}/admin/transactions`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    }),
                    authenticatedFetch(`${API_URL}/admin/total-debt`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    })
                ]);

                // Use total_debt from latest event (more efficient and solid)
                const totalDebt = totalDebtResponse.total_debt || 0;

                const formatAmount = (amt) => {
                    return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                };

                document.getElementById('totalContacts').textContent = contacts.length;
                document.getElementById('totalTransactions').textContent = transactions.length;
                const totalDebtText = `${formatAmount(totalDebt)} IQD`;
                document.getElementById('totalDebt').textContent = totalDebtText;
                currentTotalDebt = totalDebt; // Store for fallback in events
                document.getElementById('pendingReminders').textContent = '0'; // TODO
            } catch (error) {
                console.error('Error loading stats:', error);
                document.getElementById('totalContacts').textContent = 'Error';
                document.getElementById('totalTransactions').textContent = 'Error';
            }
        }

        // Events log state
        let currentPage = 0;
        let pageSize = 100;
        let searchTimeout = null;

        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentPage = 0; // Reset to first page on new search
                applyFilters();
            }, 500);
        }

        function clearFilters() {
            document.getElementById('eventSearch').value = '';
            document.getElementById('eventTypeFilter').value = '';
            document.getElementById('aggregateTypeFilter').value = '';
            document.getElementById('dateFromFilter').value = '';
            document.getElementById('dateToFilter').value = '';
            currentPage = 0;
            applyFilters();
        }

        function previousPage() {
            if (currentPage > 0) {
                currentPage--;
                applyFilters();
            }
        }

        function nextPage() {
            currentPage++;
            applyFilters();
        }

        function applyFilters() {
            pageSize = parseInt(document.getElementById('pageSize').value) || 100;
            loadEvents();
        }

        // Transactions log state
        let transactionCurrentPage = 0;
        let transactionPageSize = 100;
        let transactionSearchTimeout = null;
        let allTransactions = []; // Store all transactions for client-side filtering

        function debounceTransactionSearch() {
            clearTimeout(transactionSearchTimeout);
            transactionSearchTimeout = setTimeout(() => {
                transactionCurrentPage = 0; // Reset to first page on new search
                applyTransactionFilters();
            }, 500);
        }

        function clearTransactionFilters() {
            document.getElementById('transactionSearch').value = '';
            document.getElementById('transactionTypeFilter').value = '';
            document.getElementById('transactionDirectionFilter').value = '';
            document.getElementById('transactionDateFromFilter').value = '';
            document.getElementById('transactionDateToFilter').value = '';
            transactionCurrentPage = 0;
            applyTransactionFilters();
        }

        function previousTransactionPage() {
            if (transactionCurrentPage > 0) {
                transactionCurrentPage--;
                applyTransactionFilters();
            }
        }

        function nextTransactionPage() {
            transactionCurrentPage++;
            applyTransactionFilters();
        }

        function applyTransactionFilters() {
            transactionPageSize = parseInt(document.getElementById('transactionPageSize').value) || 100;
            loadTransactions();
        }

        async function loadEvents(silent = false) {
            if (isUpdating && !silent) return; // Prevent concurrent updates unless silent
            isUpdating = true;
            
            const loading = document.getElementById('eventsLoading');
            const table = document.getElementById('eventsTable');
            const body = document.getElementById('eventsBody');
            const countSpan = document.getElementById('eventsCount');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            // Build query parameters
            const params = new URLSearchParams();
            params.append('limit', pageSize.toString());
            params.append('offset', (currentPage * pageSize).toString());
            
            const search = document.getElementById('eventSearch').value.trim();
            if (search) {
                params.append('search', search);
            }
            
            const eventType = document.getElementById('eventTypeFilter').value;
            if (eventType) {
                params.append('event_type', eventType);
            }
            
            const aggregateType = document.getElementById('aggregateTypeFilter').value;
            if (aggregateType) {
                params.append('aggregate_type', aggregateType);
            }
            
            const dateFrom = document.getElementById('dateFromFilter').value;
            if (dateFrom) {
                params.append('date_from', dateFrom + 'T00:00:00');
            }
            
            const dateTo = document.getElementById('dateToFilter').value;
            if (dateTo) {
                params.append('date_to', dateTo + 'T23:59:59');
            }

            try {
                if (!silent) {
                    loading.style.display = 'block';
                    table.style.display = 'none';
                }
                
                const response = await authenticatedFetch(`${API_URL}/admin/events?${params.toString()}`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const events = await response.json();

                // Pre-load contact names for all events
                const contactIds = new Set();
                const undoneEventIds = new Set();
                const deletedContactIds = new Set(); // Track deleted contact IDs to look up from other events
                
                // First pass: collect all contact IDs and cache names from event_data
                events.forEach(event => {
                    const eventData = event.event_data || {};
                    
                    // Cache contact names from aggregate_id for all contact events
                    if (event.aggregate_type === 'contact') {
                        const name = eventData.name;
                        if (name && event.aggregate_id) {
                            contactCache[event.aggregate_id] = { name: name || null, username: null };
                        }
                        // For DELETE events, also cache deleted contact name using aggregate_id
                        if (eventData.deleted_contact && typeof eventData.deleted_contact === 'object' && 
                            eventData.deleted_contact !== null && eventData.deleted_contact.name && event.aggregate_id) {
                            contactCache[event.aggregate_id] = { name: eventData.deleted_contact.name || null, username: eventData.deleted_contact.username || null };
                        } else if ((event.event_type === 'CONTACT_DELETED' || event.event_type.includes('DELETE')) && event.aggregate_id) {
                            // Track deleted contact IDs to look up from other events
                            deletedContactIds.add(event.aggregate_id);
                        }
                    } else if (event.aggregate_type === 'transaction') {
                        const contactId = eventData.contact_id;
                        if (contactId) contactIds.add(contactId);
                        // For DELETE events, also get contact from deleted_transaction
                        if (eventData.deleted_transaction && typeof eventData.deleted_transaction === 'object' && 
                            eventData.deleted_transaction !== null && eventData.deleted_transaction.contact_id) {
                            contactIds.add(eventData.deleted_transaction.contact_id);
                        }
                    }
                    // Handle CONTACT_DELETED and TRANSACTION_DELETED event types
                    if (event.event_type === 'CONTACT_DELETED' || event.event_type === 'TRANSACTION_DELETED') {
                        if (eventData.deleted_contact && typeof eventData.deleted_contact === 'object' && 
                            eventData.deleted_contact !== null && eventData.deleted_contact.name && event.aggregate_id) {
                            contactCache[event.aggregate_id] = { name: eventData.deleted_contact.name || null, username: eventData.deleted_contact.username || null };
                        } else if (event.event_type === 'CONTACT_DELETED' && event.aggregate_id) {
                            deletedContactIds.add(event.aggregate_id);
                        }
                        if (eventData.deleted_transaction && typeof eventData.deleted_transaction === 'object' && 
                            eventData.deleted_transaction !== null && eventData.deleted_transaction.contact_id) {
                            contactIds.add(eventData.deleted_transaction.contact_id);
                        }
                    }
                    // Collect UNDO event IDs to fetch undone events
                    if (event.event_type === 'UNDO' && eventData.undone_event_id) {
                        undoneEventIds.add(eventData.undone_event_id);
                    }
                });
                
                // Second pass: for deleted contacts without names, try to find them in other events in this batch
                if (deletedContactIds.size > 0) {
                    events.forEach(event => {
                        // Look for CREATED or UPDATE events for the deleted contacts
                        if ((event.event_type === 'CREATED' || event.event_type === 'CREATED_CONTACT' || 
                             event.event_type.includes('CREATE') || event.event_type.includes('UPDATE')) &&
                            event.aggregate_type === 'contact' && event.aggregate_id && 
                            deletedContactIds.has(event.aggregate_id)) {
                            const name = event.event_data?.name;
                            if (name) {
                                contactCache[event.aggregate_id] = { name: name || null, username: null };
                            }
                        }
                    });
                }
                
                // Fetch missing contact data from contacts endpoint
                if (contactIds.size > 0) {
                    try {
                        const contactsResponse = await authenticatedFetch(`${API_URL}/admin/contacts`);
                        if (contactsResponse.ok) {
                            const contacts = await contactsResponse.json();
                            contacts.forEach(contact => {
                                if (contactIds.has(contact.id)) {
                                    contactCache[contact.id] = {
                                        name: contact.name || null,
                                        username: contact.username || null
                                    };
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error pre-loading contacts:', e);
                    }
                }
                
                // For deleted contacts without names, fetch from CREATED events
                // Also collect transaction aggregate_ids for DELETE transaction events
                const deletedTransactionIds = new Set();
                events.forEach(event => {
                    if ((event.event_type === 'DELETED' || event.event_type.includes('DELETE')) && 
                        event.aggregate_type === 'transaction' && event.aggregate_id) {
                        deletedTransactionIds.add(event.aggregate_id);
                    }
                });
                
                if (deletedContactIds.size > 0 || deletedTransactionIds.size > 0) {
                    try {
                        // Fetch CREATED events for contacts
                        if (deletedContactIds.size > 0) {
                            const createdContactEventsResponse = await authenticatedFetch(`${API_URL}/admin/events?limit=10000&event_type=CREATED&aggregate_type=contact`);
                            if (createdContactEventsResponse.ok) {
                                const createdContactEvents = await createdContactEventsResponse.json();
                                createdContactEvents.forEach(evt => {
                                    if (evt.aggregate_type === 'contact' && evt.aggregate_id && 
                                        deletedContactIds.has(evt.aggregate_id) && 
                                        evt.event_data?.name) {
                                        contactCache[evt.aggregate_id] = { name: evt.event_data.name || null, username: evt.event_data.username || null };
                                    }
                                });
                            }
                        }
                        
                        // Fetch CREATED events for transactions to get their contact_ids
                        if (deletedTransactionIds.size > 0) {
                            const createdTransactionEventsResponse = await authenticatedFetch(`${API_URL}/admin/events?limit=10000&event_type=CREATED&aggregate_type=transaction`);
                            if (createdTransactionEventsResponse.ok) {
                                const createdTransactionEvents = await createdTransactionEventsResponse.json();
                                createdTransactionEvents.forEach(evt => {
                                    if (evt.aggregate_type === 'transaction' && evt.aggregate_id && 
                                        deletedTransactionIds.has(evt.aggregate_id) && 
                                        evt.event_data?.contact_id) {
                                        contactIds.add(evt.event_data.contact_id);
                                    }
                                });
                                // Re-fetch contacts for these transaction contact IDs
                                if (contactIds.size > 0) {
                                    const contactsResponse = await authenticatedFetch(`${API_URL}/admin/contacts`);
                                    if (contactsResponse.ok) {
                                        const contacts = await contactsResponse.json();
                            contacts.forEach(contact => {
                                if (contactIds.has(contact.id)) {
                                    contactCache[contact.id] = { name: contact.name || null, username: contact.username || null };
                                }
                            });
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error fetching names from CREATED events:', e);
                    }
                }
                
                // Fetch undone events to show what was undone
                if (undoneEventIds.size > 0) {
                    try {
                        // Fetch all events to find the undone ones (they might be in a different page)
                        const allEventsResponse = await authenticatedFetch(`${API_URL}/admin/events?limit=10000&offset=0`);
                        if (allEventsResponse.ok) {
                            const allEvents = await allEventsResponse.json();
                            const newContactIds = new Set();
                            
                            allEvents.forEach(evt => {
                                if (undoneEventIds.has(evt.event_id)) {
                                    undoneEventsCache[evt.event_id] = evt;
                                    // The undone event is usually a DELETED event, so we need to get the name from CREATED events
                                    if (evt.aggregate_type === 'contact' && evt.aggregate_id) {
                                        const name = evt.event_data?.name;
                                        if (name) {
                                            contactCache[evt.aggregate_id] = name;
                                        } else {
                                            // If no name in event_data (DELETED event), we need to find CREATED event
                                            deletedContactIds.add(evt.aggregate_id);
                                        }
                                    }
                                    // For undone transactions, get contact_id from CREATED transaction event
                                    if (evt.aggregate_type === 'transaction' && evt.aggregate_id) {
                                        const contactId = evt.event_data?.contact_id;
                                        if (contactId) {
                                            newContactIds.add(contactId);
                                        } else {
                                            // If no contact_id (DELETED event), we need to find CREATED event
                                            deletedTransactionIds.add(evt.aggregate_id);
                                        }
                                    }
                                }
                            });
                            
                            // Add new contact IDs to the main set
                            newContactIds.forEach(id => contactIds.add(id));
                            
                            // Re-fetch contacts if we found new ones
                            if (contactIds.size > 0) {
                                const contactsResponse = await authenticatedFetch(`${API_URL}/admin/contacts`);
                                if (contactsResponse.ok) {
                                    const contacts = await contactsResponse.json();
                            contacts.forEach(contact => {
                                if (contactIds.has(contact.id)) {
                                    contactCache[contact.id] = { name: contact.name || null, username: contact.username || null };
                                }
                            });
                                }
                            }
                            
                            // For undone contacts without names, fetch from CREATED events
                            if (deletedContactIds.size > 0) {
                                const createdEventsResponse = await authenticatedFetch(`${API_URL}/admin/events?limit=10000&event_type=CREATED&aggregate_type=contact`);
                                if (createdEventsResponse.ok) {
                                    const createdEvents = await createdEventsResponse.json();
                                    createdEvents.forEach(evt => {
                                        if (evt.aggregate_type === 'contact' && evt.aggregate_id && 
                                            deletedContactIds.has(evt.aggregate_id) && 
                                            evt.event_data?.name) {
                                            contactCache[evt.aggregate_id] = { name: evt.event_data.name || null, username: evt.event_data.username || null };
                                        }
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error pre-loading undone events:', e);
                    }
                }

                if (!silent) {
                loading.style.display = 'none';
                }
                table.style.display = 'table';
                
                // Update count
                countSpan.textContent = `Showing ${events.length} event(s)`;
                
                // Update pagination
                pageInfo.textContent = `Page ${currentPage + 1}`;
                prevBtn.disabled = currentPage === 0;
                prevBtn.style.opacity = currentPage === 0 ? '0.5' : '1';
                prevBtn.style.cursor = currentPage === 0 ? 'not-allowed' : 'pointer';
                nextBtn.disabled = events.length < pageSize;
                nextBtn.style.opacity = events.length < pageSize ? '0.5' : '1';
                nextBtn.style.cursor = events.length < pageSize ? 'not-allowed' : 'pointer';
                
                // Smooth DOM update - only replace if content changed
                const newContent = renderEvents(events);
                const currentContent = body.innerHTML;
                
                if (newContent !== currentContent) {
                    // Add fade effect for smooth update
                    if (silent) {
                        body.style.transition = 'opacity 0.2s';
                        body.style.opacity = '0.7';
                        setTimeout(() => {
                            body.innerHTML = newContent;
                            body.style.opacity = '1';
                        }, 100);
                    } else {
                        body.innerHTML = newContent;
                    }
                }
            } catch (error) {
                if (!silent) {
                loading.innerHTML = `<div class="error">Error loading events: ${error.message}</div>`;
                }
                console.error('Error:', error);
            } finally {
                isUpdating = false;
            }
        }
        
        // Extract event rendering to separate function for reuse
        // Cache for contact data (name and username) - keyed by contact ID
        let contactCache = {}; // { contactId: { name: string, username: string|null } }
        // Cache for undone events (to show what was undone)
        let undoneEventsCache = {};
        
        async function getContactName(contactId) {
            if (!contactId) return null;
            if (contactCache[contactId]) return contactCache[contactId];
            
            try {
                const response = await authenticatedFetch(`${API_URL}/admin/contacts`);
                if (response.ok) {
                    const contacts = await response.json();
                    const contact = contacts.find(c => c.id === contactId);
                    if (contact) {
                        contactCache[contactId] = contact.name;
                        return contact.name;
                    }
                }
            } catch (e) {
                console.error('Error fetching contact name:', e);
            }
            return null;
        }
        
        // Event modal functions
        function showEventModal(event) {
            const modal = document.getElementById('eventModal');
            const body = document.getElementById('eventModalBody');
            
            const eventData = event.event_data || {};
            const contactId = eventData.contact_id || null;
            const contactName = contactId ? (contactCache[contactId] || 'Unknown') : null;
            
            let html = '';
            
            // Basic Info
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Event ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(event.event_id) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Event Type</div><div class="event-modal-field-value">' + escapeHtml(event.event_type) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Aggregate Type</div><div class="event-modal-field-value">' + escapeHtml(event.aggregate_type) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Aggregate ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(event.aggregate_id) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Created At</div><div class="event-modal-field-value">' + formatDateTime(event.created_at) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">User</div><div class="event-modal-field-value">' + escapeHtml(eventData.username || event.user_email || event.user_id) + '</div></div>';
            
            // Handle UNDO events
            if (event.event_type === 'UNDO' && eventData.undone_event_id) {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Event ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(eventData.undone_event_id) + '</div></div>';
                if (undoneEventsCache[eventData.undone_event_id]) {
                    const undoneEvent = undoneEventsCache[eventData.undone_event_id];
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Event Type</div><div class="event-modal-field-value">' + escapeHtml(undoneEvent.event_type) + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Aggregate Type</div><div class="event-modal-field-value">' + escapeHtml(undoneEvent.aggregate_type) + '</div></div>';
                    if (undoneEvent.aggregate_type === 'contact') {
                        const undoneName = undoneEvent.event_data?.name || 'Unknown';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Contact</div><div class="event-modal-field-value">' + escapeHtml(undoneName) + '</div></div>';
                    } else if (undoneEvent.aggregate_type === 'transaction') {
                        const undoneContactId = undoneEvent.event_data?.contact_id;
                        const undoneContactName = undoneContactId ? (contactCache[undoneContactId] || 'Unknown Contact') : 'Unknown Contact';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Transaction Contact</div><div class="event-modal-field-value">' + escapeHtml(undoneContactName) + '</div></div>';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Transaction Amount</div><div class="event-modal-field-value">' + (undoneEvent.event_data?.amount ? (undoneEvent.event_data.amount.toLocaleString('en-US') + ' ' + (undoneEvent.event_data.currency || 'IQD')) : 'N/A') + '</div></div>';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Transaction Direction</div><div class="event-modal-field-value">' + escapeHtml(undoneEvent.event_data?.direction || 'N/A') + '</div></div>';
                    }
                } else {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Event</div><div class="event-modal-field-value" style="color: #938F99;">Not loaded (event may be outside current page)</div></div>';
                }
            }
            // Handle DELETE events
            else if (event.event_type.includes('DELETE') || event.event_type.includes('DELETED')) {
                if (eventData.deleted_contact) {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label" style="color: #BA1A1A; font-weight: 700;">Deleted Contact</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Name</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.name || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Username</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.username || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Phone</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.phone || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Email</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.email || 'N/A') + '</div></div>';
                }
                if (eventData.deleted_transaction) {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label" style="color: #BA1A1A; font-weight: 700;">Deleted Transaction</div></div>';
                    const deletedTx = eventData.deleted_transaction;
                    const deletedContactId = deletedTx.contact_id;
                    const deletedContactName = deletedContactId ? (contactCache[deletedContactId] || 'Unknown Contact') : 'Unknown Contact';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact</div><div class="event-modal-field-value">' + escapeHtml(deletedContactName) + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Type</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.type || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Direction</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.direction || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Amount</div><div class="event-modal-field-value">' + (deletedTx.amount ? deletedTx.amount.toLocaleString('en-US') + ' ' + (deletedTx.currency || 'IQD') : 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Description</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.description || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Transaction Date</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.transaction_date || 'N/A') + '</div></div>';
                }
            }
            // Contact Info
            else if (event.aggregate_type === 'contact') {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact Name</div><div class="event-modal-field-value">' + escapeHtml(eventData.name || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Username</div><div class="event-modal-field-value">' + escapeHtml(eventData.username || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Phone</div><div class="event-modal-field-value">' + escapeHtml(eventData.phone || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Email</div><div class="event-modal-field-value">' + escapeHtml(eventData.email || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Notes</div><div class="event-modal-field-value">' + escapeHtml(eventData.notes || 'N/A') + '</div></div>';
            } else if (event.aggregate_type === 'transaction') {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact</div><div class="event-modal-field-value">' + escapeHtml(contactName || 'Unknown') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Type</div><div class="event-modal-field-value">' + escapeHtml(eventData.type || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Direction</div><div class="event-modal-field-value">' + escapeHtml(eventData.direction || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Amount</div><div class="event-modal-field-value">' + (eventData.amount ? eventData.amount.toLocaleString('en-US') + ' ' + (eventData.currency || 'IQD') : 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Transaction Date</div><div class="event-modal-field-value">' + escapeHtml(eventData.transaction_date || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Due Date</div><div class="event-modal-field-value">' + escapeHtml(eventData.due_date || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Description</div><div class="event-modal-field-value">' + escapeHtml(eventData.description || 'N/A') + '</div></div>';
            }
            
            // Total Debt
            if (eventData.total_debt !== null && eventData.total_debt !== undefined) {
                const debt = Number(eventData.total_debt);
                if (!isNaN(debt) && isFinite(debt)) {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Total Debt (after this event)</div><div class="event-modal-field-value" style="font-weight: 600; color: #6750A4; font-size: 1.1rem;">' + Math.round(debt).toLocaleString('en-US') + ' IQD</div></div>';
                }
            }
            
            // Comment
            if (eventData.comment) {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Comment</div><div class="event-modal-field-value">' + escapeHtml(eventData.comment) + '</div></div>';
            }
            
            // Full Event Data
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Full Event Data (JSON)</div><pre class="details-pre" style="padding: 1rem; border-radius: 4px; overflow: auto; max-height: 300px; font-size: 0.85rem; margin-top: 0.5rem;">' + escapeHtml(JSON.stringify(event, null, 2)) + '</pre></div>';
            
            body.innerHTML = html;
            modal.classList.add('active');
        }
        
        function closeEventModal(e) {
            if (e && e.target.id !== 'eventModal' && !e.target.classList.contains('event-modal-close')) {
                return;
            }
            const modal = document.getElementById('eventModal');
            modal.classList.remove('active');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function renderEvents(events) {
            return events.map(event => {
                    // event.event_data is already a parsed JSON object from the API
                    const eventData = event.event_data || {};
                    const comment = eventData.comment || eventData.Comment || null;
                    const name = eventData.name || eventData.Name || null;
                    const amount = eventData.amount || null;
                    const direction = eventData.direction || null;
                    const type = eventData.type || null;
                    const description = eventData.description || null;
                    const contactId = eventData.contact_id || null;
                    const username = eventData.username || eventData.Username || null;
                    // Get total_debt from event_data (this is the value saved in the database at event execution time)
                    let totalDebt = null;
                    
                    // eventData is already a parsed JSON object from the database
                    if (eventData && typeof eventData === 'object') {
                        // Check for total_debt (snake_case - as stored in database)
                        if (eventData.hasOwnProperty('total_debt')) {
                            totalDebt = eventData.total_debt;
                        }
                        // Also check for totalDebt (camelCase - just in case)
                        else if (eventData.hasOwnProperty('totalDebt')) {
                            totalDebt = eventData.totalDebt;
                        }
                    }
                    
                    // Convert to number if needed (handle string, number, or other types)
                    if (totalDebt !== null && totalDebt !== undefined) {
                        if (typeof totalDebt === 'number') {
                            // Already a number, check if valid
                            if (isNaN(totalDebt) || !isFinite(totalDebt)) {
                                totalDebt = null;
                            }
                        } else if (typeof totalDebt === 'string') {
                            const parsed = parseFloat(totalDebt);
                            if (!isNaN(parsed) && isFinite(parsed)) {
                                totalDebt = parsed;
                            } else {
                                totalDebt = null;
                            }
                        } else {
                            // Try to convert other types to number
                            const num = Number(totalDebt);
                            if (!isNaN(num) && isFinite(num)) {
                                totalDebt = num;
                            } else {
                                totalDebt = null;
                            }
                        }
                    }
                    
                    // Handle DELETE events - extract deleted item info
                    let deletedContactName = null;
                    let deletedTransactionInfo = null;
                    // deleted_contact is an object (not an array), and might be null
                    // Check if it exists and has a name property
                    if (eventData.deleted_contact) {
                        if (typeof eventData.deleted_contact === 'object' && eventData.deleted_contact !== null) {
                            deletedContactName = eventData.deleted_contact.name || null;
                        } else if (typeof eventData.deleted_contact === 'string') {
                            // In case it's serialized as a string
                            try {
                                const parsed = JSON.parse(eventData.deleted_contact);
                                deletedContactName = parsed.name || null;
                            } catch (e) {
                                // Ignore parse errors
                            }
                        }
                    }
                    // deleted_transaction is also an object (not an array), and might be null
                    if (eventData.deleted_transaction) {
                        if (typeof eventData.deleted_transaction === 'object' && eventData.deleted_transaction !== null) {
                            const deletedTx = eventData.deleted_transaction;
                            const deletedContactId = deletedTx.contact_id; // This is a string UUID
                            deletedTransactionInfo = {
                                contactId: deletedContactId,
                                amount: deletedTx.amount,
                                direction: deletedTx.direction,
                                description: deletedTx.description
                            };
                        } else if (typeof eventData.deleted_transaction === 'string') {
                            // In case it's serialized as a string
                            try {
                                const parsed = JSON.parse(eventData.deleted_transaction);
                                deletedTransactionInfo = {
                                    contactId: parsed.contact_id,
                                    amount: parsed.amount,
                                    direction: parsed.direction,
                                    description: parsed.description
                                };
                            } catch (e) {
                                // Ignore parse errors
                            }
                        }
                    }
                    
                    // Handle UNDO events - will be populated later
                    let undoneEventInfo = null;
                    if (event.event_type === 'UNDO' && eventData.undone_event_id) {
                        // We'll fetch this in loadEvents
                        undoneEventInfo = { undoneEventId: eventData.undone_event_id };
                    }
                    
                    // Determine contact name - show name instead of ID
                    let contactName = null;
                    let contactUsername = null; // Username of the contact (not the event user)
                    
                    // Helper function to get contact data from cache
                    const getContactData = (contactId) => {
                        if (!contactId) return null;
                        const cached = contactCache[contactId];
                        // Handle both old format (string) and new format (object)
                        if (typeof cached === 'string') {
                            return { name: cached, username: null };
                        }
                        return cached || null;
                    };
                    
                    // For UNDO events, show what was undone (check this first)
                    if (event.event_type === 'UNDO' || event.event_type.toUpperCase() === 'UNDO') {
                        // Try to get undone event info from cache
                        const undoneEventId = eventData.undone_event_id;
                        if (undoneEventId && undoneEventsCache[undoneEventId]) {
                            const undoneEvent = undoneEventsCache[undoneEventId];
                            // The undone event is usually a DELETED event, so we need to get the name from CREATED event
                            if (undoneEvent.aggregate_type === 'contact') {
                                // Get contact name from CREATED event using aggregate_id
                                const undoneContactId = undoneEvent.aggregate_id;
                                const contactData = getContactData(undoneContactId);
                                const undoneName = contactData?.name;
                                if (contactData && undoneName) {
                                    contactName = `Undone: ${undoneName}`; contactUsername = contactData?.username || null;
                                } else {
                                    // Try to find CREATED event in current batch
                                    const createdEvent = events.find(e => 
                                        e.aggregate_type === 'contact' && 
                                        e.aggregate_id === undoneContactId &&
                                        (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                    );
                                    if (createdEvent && createdEvent.event_data?.name) {
                                        contactName = `Undone: ${createdEvent.event_data.name}`;
                                        contactCache[undoneContactId] = createdEvent.event_data.name;
                                        if (createdEvent.event_data?.username) {
                                            contactUsername = createdEvent.event_data.username;
                                            // Update cache with both name and username
                                            const existing = contactCache[undoneContactId] || {};
                                            contactCache[undoneContactId] = {
                                                name: existing.name || createdEvent.event_data.name || null,
                                                username: createdEvent.event_data.username
                                            };
                                        }
                                    } else {
                                        contactName = `Undone: ${undoneContactId.substring(0, 8)}...`;
                                    }
                                }
                                // Get username from cache or undone event
                                if (!contactUsername) {
                                    const cached = contactCache[undoneEvent.aggregate_id];
                                    contactUsername = cached?.username || undoneEvent.event_data?.username || null;
                                }
                            } else if (undoneEvent.aggregate_type === 'transaction') {
                                // For undone transaction, get contact from the transaction's CREATED event
                                const undoneTransactionId = undoneEvent.aggregate_id;
                                // Try to find the CREATED event for this transaction to get contact_id
                                let undoneContactId = null;
                                // Look in the events we already have
                                const createdTxEvent = events.find(e => 
                                    e.aggregate_type === 'transaction' && 
                                    e.aggregate_id === undoneTransactionId &&
                                    (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                );
                                if (createdTxEvent && createdTxEvent.event_data?.contact_id) {
                                    undoneContactId = createdTxEvent.event_data.contact_id;
                                }
                                
                                const contactData = undoneContactId ? getContactData(undoneContactId) : null;
                                const undoneContactName = contactData?.name || 'Unknown Contact';
                                const undoneAmount = undoneEvent.event_data?.amount;
                                const undoneDirection = undoneEvent.event_data?.direction;
                                if (undoneAmount !== null && undoneAmount !== undefined) {
                                    const sign = undoneDirection === 'lent' ? '+' : '-';
                                    contactName = `Undone: ${undoneContactName} (${sign}${Math.round(Number(undoneAmount)).toLocaleString('en-US')} IQD)`;
                                } else {
                                    contactName = `Undone: ${undoneContactName}`;
                                }
                                contactUsername = contactData?.username || null;
                            } else {
                                contactName = 'Undone Event';
                            }
                        } else if (event.aggregate_id) {
                            const contactData = getContactData(event.aggregate_id);
                            if (contactData && contactData.name) {
                                contactName = `Undone: ${contactData.name}`;
                                contactUsername = contactData.username || null;
                            } else {
                                contactName = 'Undone Event';
                            }
                        } else {
                            contactName = 'Undone Event';
                        }
                    }
                    // For DELETE events, use deleted item info
                    else if (event.event_type.includes('DELETE') || event.event_type.includes('DELETED') || 
                             event.event_type === 'CONTACT_DELETED' || event.event_type === 'TRANSACTION_DELETED') {
                        if (event.aggregate_type === 'contact' || event.event_type === 'CONTACT_DELETED') {
                            // For DELETE contact events, use deleted_contact name
                            // Priority: deleted_contact.name > aggregate_id from cache > name from event_data
                            if (deletedContactName) {
                                contactName = deletedContactName;
                                if (eventData.deleted_contact && typeof eventData.deleted_contact === 'object') {
                                    contactUsername = eventData.deleted_contact.username || null;
                                }
                            } else if (event.aggregate_id) {
                                const contactData = getContactData(event.aggregate_id);
                                contactName = contactData?.name || 'Unknown';
                                contactUsername = contactData?.username || null;
                            } else {
                                contactName = name || 'Unknown';
                                contactUsername = username || null;
                            }
                        } else if (event.aggregate_type === 'transaction' || event.event_type === 'TRANSACTION_DELETED' || event.event_type === 'DELETED') {
                            // For DELETE transaction events, use deleted_transaction contact
                            // Priority: deleted_transaction.contact_id > contact_id from event_data > CREATED event lookup
                            let deletedContactId = null;
                            if (deletedTransactionInfo && deletedTransactionInfo.contactId) {
                                deletedContactId = deletedTransactionInfo.contactId;
                            } else if (contactId) {
                                deletedContactId = contactId;
                            } else if (event.aggregate_id) {
                                // Try to get contact_id from CREATED transaction event
                                const createdTxEvent = events.find(e => 
                                    e.aggregate_type === 'transaction' && 
                                    e.aggregate_id === event.aggregate_id &&
                                    (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                );
                                if (createdTxEvent && createdTxEvent.event_data?.contact_id) {
                                    deletedContactId = createdTxEvent.event_data.contact_id;
                                }
                            }
                            const contactData = deletedContactId ? getContactData(deletedContactId) : null;
                            contactName = contactData?.name || 'Unknown Contact';
                            contactUsername = contactData?.username || null;
                        }
                    }
                    // For regular events
                    else if (event.aggregate_type === 'contact') {
                        const contactData = event.aggregate_id ? getContactData(event.aggregate_id) : null;
                        contactName = name || contactData?.name || 'Unknown';
                        contactUsername = username || contactData?.username || null;
                    } else if (event.aggregate_type === 'transaction') {
                        if (contactId) {
                            const contactData = getContactData(contactId);
                            contactName = contactData?.name || 'Unknown Contact';
                            contactUsername = contactData?.username || null;
                        } else if (event.aggregate_id) {
                            // Try to get contact_id from CREATED transaction event
                            const createdTxEvent = events.find(e => 
                                e.aggregate_type === 'transaction' && 
                                e.aggregate_id === event.aggregate_id &&
                                (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                            );
                            if (createdTxEvent && createdTxEvent.event_data?.contact_id) {
                                const txContactId = createdTxEvent.event_data.contact_id;
                                const contactData = getContactData(txContactId);
                                contactName = contactData?.name || 'Unknown Contact';
                                contactUsername = contactData?.username || null;
                            } else {
                                contactName = 'Unknown Contact';
                            }
                        }
                    }
                    
                    // User display - show username only (no ID)
                    const userDisplay = username || event.user_email || 'N/A';
                    
                    // Format total debt - show the value saved in database at event execution time
                    let totalDebtDisplay = 'N/A';
                    if (totalDebt !== null && totalDebt !== undefined) {
                        const num = Number(totalDebt);
                        if (!isNaN(num) && isFinite(num)) {
                            totalDebtDisplay = `${Math.round(num).toLocaleString('en-US')} IQD`;
                        }
                    }
                    
                    // Get event type badge color
                    let badgeClass = 'badge';
                    const eventTypeUpper = event.event_type.toUpperCase();
                    if (eventTypeUpper.includes('CREATED') || eventTypeUpper.includes('CREATE')) {
                        badgeClass += ' success';
                    } else if (eventTypeUpper.includes('UPDATED') || eventTypeUpper.includes('UPDATE')) {
                        badgeClass += ' warning';
                    } else if (eventTypeUpper.includes('DELETED') || eventTypeUpper.includes('DELETE')) {
                        // DELETE events use warning badge (same as UPDATE) to match other events
                        badgeClass += ' warning';
                    } else if (eventTypeUpper === 'UNDO') {
                        badgeClass += ' warning';
                    }
                    
                    // Format event type for display - make it more specific
                    let displayEventType = event.event_type;
                    
                    // Handle UNDO events specially - show what's being undone
                    if (event.event_type === 'UNDO' || event.event_type.toUpperCase() === 'UNDO') {
                        const undoneEventId = eventData.undone_event_id;
                        if (undoneEventId && undoneEventsCache[undoneEventId]) {
                            const undoneEvent = undoneEventsCache[undoneEventId];
                            const undoneType = undoneEvent.event_type || 'Event';
                            const undoneAggregate = undoneEvent.aggregate_type || '';
                            
                            // Format: "Undo [Aggregate] [Action]"
                            // e.g., "Undo Contact Delete", "Undo Transaction Update"
                            let undoneAction = '';
                            if (undoneType.includes('DELETE') || undoneType.includes('DELETED')) {
                                undoneAction = 'Delete';
                            } else if (undoneType.includes('UPDATE') || undoneType.includes('UPDATED')) {
                                undoneAction = 'Update';
                            } else if (undoneType.includes('CREATE') || undoneType.includes('CREATED')) {
                                undoneAction = 'Create';
                            } else {
                                undoneAction = undoneType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            }
                            
                            const aggregateName = undoneAggregate.charAt(0).toUpperCase() + undoneAggregate.slice(1);
                            displayEventType = `Undo ${aggregateName} ${undoneAction}`;
                        } else {
                            displayEventType = 'Undo';
                        }
                    }
                    // If event type is generic (CREATED, UPDATED, DELETED), make it specific based on aggregate_type
                    else {
                        const genericTypes = ['CREATED', 'UPDATED', 'DELETED', 'CREATE', 'UPDATE', 'DELETE'];
                        const isGeneric = genericTypes.some(gt => event.event_type.toUpperCase() === gt || 
                                                                  event.event_type.toUpperCase().includes(gt));
                        
                        // Check if event type already has aggregate in it (e.g., CONTACT_DELETED, TRANSACTION_DELETED)
                        const eventTypeUpper = event.event_type.toUpperCase();
                        if (eventTypeUpper.includes('_CONTACT') || eventTypeUpper.includes('_TRANSACTION')) {
                            // Event type already includes aggregate, just format it
                            displayEventType = event.event_type;
                        } else if (isGeneric && event.aggregate_type) {
                            // Convert to specific format: CREATED_TRANSACTION, UPDATE_TRANSACTION, DELETE_TRANSACTION, etc.
                            const action = event.event_type.toUpperCase();
                            let specificAction = '';
                            
                            if (action.includes('CREATED') || action.includes('CREATE')) {
                                specificAction = 'CREATED';
                            } else if (action.includes('UPDATED') || action.includes('UPDATE')) {
                                specificAction = 'UPDATE';
                            } else if (action.includes('DELETED') || action.includes('DELETE')) {
                                specificAction = 'DELETE';
                            } else {
                                specificAction = action;
                            }
                            
                            const aggregateUpper = event.aggregate_type.toUpperCase();
                            displayEventType = `${specificAction}_${aggregateUpper}`;
                        }
                        
                        // Format for display (replace underscores with spaces, capitalize words)
                        displayEventType = displayEventType
                            .replace(/_/g, ' ')
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                            .join(' ');
                    }
                    
                    // contactName is already determined above - use it directly
                    
                    // Format amount display with +/- and colors
                    let amountDisplay = '-';
                    
                    // For UNDO events, show undone transaction amount or contact balance impact (check this first)
                    if (event.event_type === 'UNDO' || event.event_type.toUpperCase() === 'UNDO') {
                        const undoneEventId = eventData.undone_event_id;
                        if (undoneEventId && undoneEventsCache[undoneEventId]) {
                            const undoneEvent = undoneEventsCache[undoneEventId];
                            // If undoing a transaction, show the transaction amount
                            if (undoneEvent.aggregate_type === 'transaction') {
                                let undoneAmount = null;
                                let undoneDirection = null;
                                
                                // First try to get from undone event's event_data (for UPDATE events)
                                if (undoneEvent.event_data?.amount !== null && undoneEvent.event_data?.amount !== undefined) {
                                    undoneAmount = undoneEvent.event_data.amount;
                                    undoneDirection = undoneEvent.event_data.direction;
                                }
                                // If undone event is DELETE, try to get from deleted_transaction
                                else if (undoneEvent.event_data?.deleted_transaction) {
                                    undoneAmount = undoneEvent.event_data.deleted_transaction.amount;
                                    undoneDirection = undoneEvent.event_data.deleted_transaction.direction;
                                }
                                
                                // If still no amount, try to find CREATED transaction event in current batch
                                if ((undoneAmount === null || undoneAmount === undefined) && undoneEvent.aggregate_id) {
                                    const createdTxEvent = events.find(e => 
                                        e.aggregate_type === 'transaction' && 
                                        e.aggregate_id === undoneEvent.aggregate_id &&
                                        (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                    );
                                    if (createdTxEvent && createdTxEvent.event_data?.amount) {
                                        undoneAmount = createdTxEvent.event_data.amount;
                                        undoneDirection = createdTxEvent.event_data.direction || 'owed';
                                    }
                                }
                                
                                // Display the amount if we found it
                                if (undoneAmount !== null && undoneAmount !== undefined) {
                                    const amountNum = Number(undoneAmount);
                                    if (!isNaN(amountNum) && isFinite(amountNum)) {
                                        const sign = (undoneDirection || 'owed') === 'lent' ? '+' : '-';
                                        const amountColor = (undoneDirection || 'owed') === 'lent' ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                        amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} IQD</span>`;
                                    }
                                }
                            }
                            // If undoing a contact delete, calculate the net balance impact from total_debt change
                            else if (undoneEvent.aggregate_type === 'contact') {
                                // Find the DELETE event for this contact to get the total_debt before deletion
                                const deleteEvent = events.find(e => 
                                    e.aggregate_type === 'contact' &&
                                    e.aggregate_id === undoneEvent.aggregate_id &&
                                    (e.event_type === 'DELETED' || e.event_type.includes('DELETE'))
                                );
                                
                                if (deleteEvent && deleteEvent.event_data?.total_debt !== null && deleteEvent.event_data?.total_debt !== undefined &&
                                    totalDebt !== null && totalDebt !== undefined) {
                                    const deleteTotalDebt = Number(deleteEvent.event_data.total_debt);
                                    const undoTotalDebt = Number(totalDebt);
                                    
                                    if (!isNaN(deleteTotalDebt) && !isNaN(undoTotalDebt)) {
                                        // The difference is the net impact of restoring the contact
                                        const netImpact = undoTotalDebt - deleteTotalDebt;
                                        
                                        if (netImpact !== 0) {
                                            const sign = netImpact > 0 ? '+' : '-';
                                            const amountColor = netImpact > 0 ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                            amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.abs(Math.round(netImpact)).toLocaleString('en-US')} IQD</span>`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // For DELETE contact events, calculate the net balance impact from total_debt change
                    else if ((event.event_type === 'DELETED' || event.event_type.includes('DELETE')) && 
                             event.aggregate_type === 'contact') {
                        // Find the event before this DELETE to get total_debt before deletion
                        const currentIndex = events.findIndex(e => e.event_id === event.event_id);
                        if (currentIndex > 0) {
                            const previousEvent = events[currentIndex - 1];
                            const previousTotalDebt = previousEvent.event_data?.total_debt;
                            
                            if (previousTotalDebt !== null && previousTotalDebt !== undefined &&
                                totalDebt !== null && totalDebt !== undefined) {
                                const beforeTotalDebt = Number(previousTotalDebt);
                                const afterTotalDebt = Number(totalDebt);
                                
                                if (!isNaN(beforeTotalDebt) && !isNaN(afterTotalDebt)) {
                                    // The difference is the net impact of deleting the contact
                                    const netImpact = afterTotalDebt - beforeTotalDebt;
                                    
                                    if (netImpact !== 0) {
                                        const sign = netImpact > 0 ? '+' : '-';
                                        const amountColor = netImpact > 0 ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                        amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.abs(Math.round(netImpact)).toLocaleString('en-US')} IQD</span>`;
                                    }
                                }
                            }
                        }
                    }
                    // For DELETE transaction events, show deleted transaction amount
                    else if (deletedTransactionInfo && deletedTransactionInfo.amount !== null && deletedTransactionInfo.amount !== undefined) {
                        const amountNum = Number(deletedTransactionInfo.amount);
                        if (!isNaN(amountNum) && isFinite(amountNum)) {
                            const sign = deletedTransactionInfo.direction === 'lent' ? '+' : '-';
                            const amountColor = deletedTransactionInfo.direction === 'lent' ? 'color: #16A34A;' : 'color: #BA1A1A;';
                            amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} IQD</span>`;
                        }
                    }
                    // For DELETE transaction events without deleted_transaction data, try to get from CREATED event
                    else if ((event.event_type === 'DELETED' || event.event_type.includes('DELETE')) && 
                             event.aggregate_type === 'transaction' && event.aggregate_id) {
                        // Try to find CREATED transaction event to get amount
                        const createdTxEvent = events.find(e => 
                            e.aggregate_type === 'transaction' && 
                            e.aggregate_id === event.aggregate_id &&
                            (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                        );
                        if (createdTxEvent && createdTxEvent.event_data?.amount) {
                            const amountNum = Number(createdTxEvent.event_data.amount);
                            if (!isNaN(amountNum) && isFinite(amountNum)) {
                                const direction = createdTxEvent.event_data.direction || 'owed';
                                const sign = direction === 'lent' ? '+' : '-';
                                const amountColor = direction === 'lent' ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} IQD</span>`;
                            }
                        }
                    }
                    // For regular transaction events
                    else if (event.aggregate_type === 'transaction' && amount !== null) {
                        const amountNum = Number(amount);
                        if (!isNaN(amountNum) && isFinite(amountNum)) {
                            const currency = eventData.currency || 'IQD';
                            // Standardization: Received (owed) = red (negative) = -, Gave (lent) = green (positive) = +
                            const isReceived = direction === 'owed'; // owed = Received
                            const isGave = direction === 'lent'; // lent = Gave
                            const sign = isGave ? '+' : '-'; // Gave = +, Received = -
                            const amountColor = isGave ? 'color: #16A34A;' : 'color: #BA1A1A;'; // Gave = green, Received = red
                            amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} ${currency}</span>`;
                        }
                    }
                    
                    // Store event data as JSON for modal (properly escaped)
                    const eventJson = JSON.stringify(event).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    
                    return `
                        <tr class="event-row" onclick='showEventModal(${JSON.stringify(event)})' data-event-id="${event.event_id}">
                            <td style="white-space: nowrap; font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${formatDateTime(event.created_at)}
                            </td>
                            <td style="padding: 0.4rem 0.5rem;">
                                <span class="${badgeClass}" style="font-size: 0.7rem;">${displayEventType}</span>
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${contactUsername ? `<span class="username-tag">@${escapeHtml(contactUsername)}</span>` : ''}${contactName || 'Unknown'}
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${amountDisplay !== '-' ? amountDisplay : '-'}
                            </td>
                            <td style="font-size: 0.75rem; font-weight: 600; color: #6750A4; white-space: nowrap; padding: 0.4rem 0.5rem;">
                                ${totalDebtDisplay}
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${userDisplay}
                            </td>
                            <td style="max-width: 150px; font-size: 0.7rem; padding: 0.4rem 0.5rem;">
                                ${comment ? `<div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${comment.replace(/"/g, '&quot;')}">${comment.substring(0, 30)}${comment.length > 30 ? '...' : ''}</div>` : '<em style="color: #938F99;">-</em>'}
                            </td>
                            <td style="font-size: 0.7rem; padding: 0.4rem 0.5rem;">
                                <span style="color: #6750A4; cursor: pointer;">View</span>
                            </td>
                        </tr>
                    `;
            }).join('');
        }
        
        // Smart update system - only updates when there are changes
        function startSmartUpdates() {
            // Check auth first
            if (!checkAuth()) {
                console.log('‚ö†Ô∏è Cannot start smart updates - not authenticated');
                return;
            }
            
            // First, get the latest event ID
            authenticatedFetch(`${API_URL}/admin/events/latest`)
                .then(r => r.json())
                .then(data => {
                    lastEventId = data.latest_event_id;
                })
                .catch(err => {
                    // If it's an auth error, logout has already been called
                    if (err.message && err.message.includes('Authentication')) {
                        console.log('‚ö†Ô∏è Authentication failed during smart updates - user logged out');
                        return;
                    }
                    console.error('Error getting latest event ID:', err);
                });
            
            // Try WebSocket first (real-time)
            try {
                // Get auth token and include it in WebSocket URL
                const token = localStorage.getItem('auth_token');
                if (!token) {
                    console.log('‚ö†Ô∏è No auth token available for WebSocket connection - skipping');
                    return;
                }
                
                // Close existing connection if any
                if (wsConnection && wsConnection.readyState !== WebSocket.CLOSED) {
                    console.log('üîå Closing existing WebSocket connection...');
                    wsConnection.close();
                    wsConnection = null;
                }
                
                // Include token as query parameter for WebSocket authentication
                const wsUrlWithAuth = `${WS_URL}?token=${encodeURIComponent(token)}`;
                console.log('üîå Connecting WebSocket to:', wsUrlWithAuth.replace(/token=[^&]+/, 'token=***'));
                wsConnection = new WebSocket(wsUrlWithAuth);
                
                wsConnection.onopen = () => {
                    console.log('‚úÖ WebSocket connected for real-time updates');
                };
                
                wsConnection.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('üì® WebSocket message received:', message.type || 'unknown');
                        // When we receive ANY WebSocket event, immediately check for updates
                        // This ensures hot updates without delay
                        checkForUpdates();
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e, 'Raw data:', event.data);
                    }
                };
                
                wsConnection.onerror = (error) => {
                    console.log('WebSocket error:', error);
                    const token = localStorage.getItem('auth_token');
                    if (!token) {
                        console.log('‚ö†Ô∏è No auth token - not reconnecting');
                        return;
                    }
                    // Check if it's an auth error (401)
                    if (wsConnection.readyState === WebSocket.CLOSED) {
                        console.log('‚ö†Ô∏è WebSocket closed due to auth error - checking token validity...');
                        // Validate token and reconnect if valid
                        validateAuth().then(isValid => {
                            if (isValid) {
                                console.log('‚úÖ Token is valid, reconnecting WebSocket...');
                                setTimeout(() => startSmartUpdates(), 2000);
                            } else {
                                console.log('‚ö†Ô∏è Token invalid - not reconnecting');
                            }
                        });
                    } else {
                        // Other error - try to reconnect
                        setTimeout(() => {
                            if (checkAuth()) {
                                startSmartUpdates();
                            }
                        }, 2000);
                    }
                };
                
                wsConnection.onclose = (event) => {
                    console.log('WebSocket closed', event.code, event.reason);
                    // Don't reconnect if it was closed due to auth error (401)
                    if (event.code === 1008 || event.code === 1002) {
                        console.log('‚ö†Ô∏è WebSocket closed due to protocol/auth error - checking token...');
                        validateAuth().then(isValid => {
                            if (isValid) {
                                console.log('‚úÖ Token is valid, reconnecting WebSocket...');
                                setTimeout(() => startSmartUpdates(), 2000);
                            } else {
                                console.log('‚ö†Ô∏è Token invalid - not reconnecting');
                            }
                        });
                        return;
                    }
                    // Normal close - reconnect if authenticated
                    setTimeout(() => {
                        if (checkAuth()) {
                            startSmartUpdates();
                        } else {
                            console.log('‚ö†Ô∏è Not reconnecting WebSocket - user logged out');
                        }
                    }, 2000);
                };
            } catch (e) {
                console.log('WebSocket not available, using polling:', e);
                startPolling();
            }
        }
        
        // No polling - WebSocket handles all updates (like Firebase)
        // Only reconnect WebSocket if it fails
        function startPolling() {
            // No polling timer - WebSocket is the only update mechanism
            // If WebSocket fails, it will reconnect automatically
            console.log('WebSocket-only mode: No polling timers');
        }
        
        // Check for updates (used by WebSocket and polling)
        async function checkForUpdates() {
            // Check auth first
            if (!checkAuth()) {
                console.log('‚ö†Ô∏è Cannot check for updates - not authenticated');
                return;
            }
            
            try {
                const response = await authenticatedFetch(`${API_URL}/admin/events/latest`);
                const data = await response.json();
                
                if (data.latest_event_id !== null && data.latest_event_id !== lastEventId) {
                    // There are new events! Update everything immediately (like Firebase)
                    console.log('üîÑ New events detected, updating all data...');
                    lastEventId = data.latest_event_id;
                    // Refresh all data immediately when WebSocket detects changes
                    await Promise.all([
                        loadStats(),
                        loadContacts(),
                        loadTransactions(),
                        loadEvents(true), // true = silent update
                        loadDebtChart()
                    ]);
                }
            } catch (err) {
                // If it's an auth error, logout has already been called
                if (err.message && err.message.includes('Authentication')) {
                    console.log('‚ö†Ô∏è Authentication failed during update check - user logged out');
                    return;
                }
                console.error('Error checking for updates:', err);
            }
        }

        async function loadContacts() {
            const loading = document.getElementById('contactsLoading');
            const table = document.getElementById('contactsTable');
            const body = document.getElementById('contactsBody');

            try {
                const response = await authenticatedFetch(`${API_URL}/admin/contacts`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const contacts = await response.json();

                loading.style.display = 'none';
                table.style.display = 'table';
                body.innerHTML = contacts.map(contact => {
                    // Balance is stored as whole units (IQD), format with commas
                    const formatAmount = (amt) => {
                        return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };
                    const balance = contact.balance ? `${formatAmount(contact.balance)} IQD` : '0 IQD';
                    return `
                    <tr>
                        <td>${contact.id.substring(0, 8)}...</td>
                        <td>${contact.name}</td>
                        <td>${contact.username ? '@' + contact.username : '-'}</td>
                        <td>${contact.email || '-'}</td>
                        <td>${contact.phone || '-'}</td>
                        <td>${balance}</td>
                        <td>${formatDateTime(contact.created_at)}</td>
                        <td><span class="badge ${contact.is_deleted ? 'error' : 'success'}">${contact.is_deleted ? 'Deleted' : 'Active'}</span></td>
                    </tr>
                `;
                }).join('');
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading contacts: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        async function loadTransactions() {
            const loading = document.getElementById('transactionsLoading');
            const table = document.getElementById('transactionsTable');
            const body = document.getElementById('transactionsBody');
            const countSpan = document.getElementById('transactionsCount');
            const pageInfo = document.getElementById('transactionPageInfo');
            const prevBtn = document.getElementById('transactionPrevBtn');
            const nextBtn = document.getElementById('transactionNextBtn');

            try {
                // Load all transactions if not already loaded
                if (allTransactions.length === 0) {
                    const response = await authenticatedFetch(`${API_URL}/admin/transactions`);
                    if (!response.ok) {
                        const text = await response.text();
                        throw new Error(`HTTP ${response.status}: ${text}`);
                    }
                    allTransactions = await response.json();
                }

                // Load contacts for name and username mapping
                const contactsResponse = await authenticatedFetch(`${API_URL}/admin/contacts`);
                let contacts = [];
                if (contactsResponse.ok) {
                    contacts = await contactsResponse.json();
                }
                const contactMap = new Map(contacts.map(c => [c.id, { name: c.name, username: c.username || null }]));

                // Apply filters
                let filteredTransactions = [...allTransactions];
                
                const search = document.getElementById('transactionSearch').value.trim().toLowerCase();
                if (search) {
                    filteredTransactions = filteredTransactions.filter(t => {
                        const contactData = contactMap.get(t.contact_id) || { name: 'Unknown', username: null };
                        const contactName = (contactData.name || 'Unknown').toLowerCase();
                        const contactUsername = (contactData.username || '').toLowerCase();
                        const description = (t.description || '').toLowerCase();
                        return contactName.includes(search) || contactUsername.includes(search) || description.includes(search);
                    });
                }
                
                const typeFilter = document.getElementById('transactionTypeFilter').value;
                if (typeFilter) {
                    filteredTransactions = filteredTransactions.filter(t => t.type === typeFilter);
                }
                
                const directionFilter = document.getElementById('transactionDirectionFilter').value;
                if (directionFilter) {
                    filteredTransactions = filteredTransactions.filter(t => t.direction === directionFilter);
                }
                
                const dateFrom = document.getElementById('transactionDateFromFilter').value;
                if (dateFrom) {
                    const fromDate = new Date(dateFrom + 'T00:00:00');
                    filteredTransactions = filteredTransactions.filter(t => {
                        const tDate = new Date(t.transaction_date);
                        return tDate >= fromDate;
                    });
                }
                
                const dateTo = document.getElementById('transactionDateToFilter').value;
                if (dateTo) {
                    const toDate = new Date(dateTo + 'T23:59:59');
                    filteredTransactions = filteredTransactions.filter(t => {
                        const tDate = new Date(t.transaction_date);
                        return tDate <= toDate;
                    });
                }

                // Apply pagination
                const startIndex = transactionCurrentPage * transactionPageSize;
                const endIndex = startIndex + transactionPageSize;
                const paginatedTransactions = filteredTransactions.slice(startIndex, endIndex);

                loading.style.display = 'none';
                table.style.display = 'table';
                
                // Update count
                countSpan.textContent = `Showing ${paginatedTransactions.length} of ${filteredTransactions.length} transaction(s)`;
                
                // Update pagination
                pageInfo.textContent = `Page ${transactionCurrentPage + 1}`;
                prevBtn.disabled = transactionCurrentPage === 0;
                prevBtn.style.opacity = transactionCurrentPage === 0 ? '0.5' : '1';
                prevBtn.style.cursor = transactionCurrentPage === 0 ? 'not-allowed' : 'pointer';
                nextBtn.disabled = endIndex >= filteredTransactions.length;
                nextBtn.style.opacity = endIndex >= filteredTransactions.length ? '0.5' : '1';
                nextBtn.style.cursor = endIndex >= filteredTransactions.length ? 'not-allowed' : 'pointer';
                
                body.innerHTML = paginatedTransactions.map(t => {
                    // Amount is stored as whole units (IQD), format with commas
                    const formatAmount = (amt) => {
                        return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };
                    const amount = t.type === 'money' ? `${formatAmount(t.amount)} IQD` : `${t.amount} item(s)`;
                    
                    // Get contact data
                    const contactData = contactMap.get(t.contact_id) || { name: 'Unknown', username: null };
                    const contactName = contactData.name || 'Unknown';
                    const contactUsername = contactData.username;
                    
                    // Format contact with username tag (same format as events list)
                    const contactDisplay = contactUsername 
                        ? `<span class="username-tag">@${escapeHtml(contactUsername)}</span>${escapeHtml(contactName)}`
                        : escapeHtml(contactName);
                    
                    // Format direction with badge (same format as Event Type in events list)
                    let directionBadgeClass = 'badge';
                    if (t.direction === 'lent') {
                        directionBadgeClass += ' success';
                    } else {
                        directionBadgeClass += ' error';
                    }
                    const directionDisplay = t.direction === 'lent' ? 'Lent' : 'Owed';
                    
                    return `
                        <tr>
                            <td style="white-space: nowrap; font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${formatDateTime(t.transaction_date)}
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">${contactDisplay}</td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">${amount}</td>
                            <td style="padding: 0.4rem 0.5rem;">
                                <span class="${directionBadgeClass}" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.7rem; font-weight: 500;">${directionDisplay}</span>
                            </td>
                        </tr>
                    `;
                }).join('');
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading transactions: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        async function loadProjections() {
            const loading = document.getElementById('projectionsLoading');
            const content = document.getElementById('projectionsContent');
            const info = document.getElementById('projectionsInfo');

            try {
                const response = await authenticatedFetch(`${API_URL}/admin/projections/status`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const status = await response.json();

                loading.style.display = 'none';
                content.style.display = 'block';
                info.innerHTML = `
                    <div class="projection-info" style="background: #E7E0EC; padding: 1rem; border-radius: 4px; margin-bottom: 1rem; color: #1C1B1F;">
                        <strong>Last Event ID:</strong> ${status.last_event_id || 'N/A'}<br>
                        <strong>Projections Updated:</strong> ${status.projections_updated || 'N/A'}<br>
                        <strong>Last Update:</strong> ${status.last_update ? new Date(status.last_update).toLocaleString() : 'N/A'}
                    </div>
                    <pre class="details-pre" style="background: #E7E0EC; padding: 1rem; border-radius: 4px; overflow: auto; color: #1C1B1F;">${JSON.stringify(status, null, 2)}</pre>
                `;
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading projections: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        function formatDateTime(dateStr) {
            if (!dateStr) return 'N/A';
            try {
                // Handle both ISO strings and NaiveDateTime format
                const date = new Date(dateStr);
                return date.toLocaleString();
            } catch (e) {
                return dateStr;
            }
        }


        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Find and activate the clicked tab button
            document.querySelectorAll('.tab').forEach(tab => {
                if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(tabName)) {
                    tab.classList.add('active');
                }
            });
            document.getElementById(tabName).classList.add('active');
            
            // Load data when switching to specific tabs
            if (tabName === 'users') {
                loadUsers();
            } else if (tabName === 'transactions') {
                // Reset transactions cache when switching to tab to ensure fresh data
                allTransactions = [];
                loadTransactions();
            }
        }

        // User Management Functions
        async function loadUsers() {
            const loading = document.getElementById('usersLoading');
            const table = document.getElementById('usersTable');
            const body = document.getElementById('usersBody');

            try {
                const response = await authenticatedFetch(`${API_URL}/admin/users`);
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('Authentication required. Please login.');
                    }
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const users = await response.json();

                loading.style.display = 'none';
                table.style.display = 'table';
                body.innerHTML = users.map(user => `
                    <tr>
                        <td>${user.email}</td>
                        <td>${formatDateTime(user.created_at)}</td>
                        <td>
                            <button onclick="showChangePasswordModal('${user.id}', '${user.email}')" style="padding: 0.25rem 0.5rem; margin-right: 0.5rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer;">Change Password</button>
                            <button onclick="showLoginLogsModal('${user.id}', '${user.email}')" style="padding: 0.25rem 0.5rem; margin-right: 0.5rem; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Login Logs</button>
                            <button onclick="backupUserData('${user.id}', '${user.email}')" style="padding: 0.25rem 0.5rem; margin-right: 0.5rem; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Backup</button>
                            <button onclick="deleteUser('${user.id}', '${user.email}')" style="padding: 0.25rem 0.5rem; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                        </td>
                    </tr>
                `).join('');
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading users: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        function showCreateUserModal() {
            const email = prompt('Enter email for new user:');
            if (!email) return;
            
            const password = prompt('Enter password (min 8 characters):');
            if (!password || password.length < 8) {
                alert('Password must be at least 8 characters');
                return;
            }

            createUser(email, password);
        }

        async function createUser(email, password) {
            try {
                const response = await authenticatedFetch(`${API_URL}/admin/users`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ email, password })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to create user');
                }

                alert('User created successfully!');
                loadUsers();
            } catch (error) {
                alert(`Error creating user: ${error.message}`);
            }
        }

        async function deleteUser(userId, email) {
            if (!confirm(`Are you sure you want to delete user ${email}? This action cannot be undone.`)) {
                return;
            }

            try {
                const response = await authenticatedFetch(`${API_URL}/admin/users/${userId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete user');
                }

                alert('User deleted successfully!');
                loadUsers();
            } catch (error) {
                alert(`Error deleting user: ${error.message}`);
            }
        }

        function showChangePasswordModal(userId, email) {
            const newPassword = prompt(`Enter new password for ${email} (min 8 characters):`);
            if (!newPassword || newPassword.length < 8) {
                alert('Password must be at least 8 characters');
                return;
            }

            changeUserPassword(userId, newPassword);
        }

        async function changeUserPassword(userId, newPassword) {
            try {
                const response = await authenticatedFetch(`${API_URL}/admin/users/${userId}/password`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ new_password: newPassword })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to change password');
                }

                alert('Password changed successfully!');
            } catch (error) {
                alert(`Error changing password: ${error.message}`);
            }
        }

        async function showLoginLogsModal(userId, email) {
            try {
                const response = await authenticatedFetch(`${API_URL}/admin/users/${userId}/login-logs`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to load login logs');
                }

                const logs = await response.json();
                const logsText = logs.map(log => 
                    `${formatDateTime(log.login_at)} - ${log.success ? '‚úÖ Success' : '‚ùå Failed'}${log.failure_reason ? ' (' + log.failure_reason + ')' : ''}${log.ip_address ? ' - IP: ' + log.ip_address : ''}`
                ).join('\n');

                alert(`Login Logs for ${email}:\n\n${logsText || 'No login logs found'}`);
            } catch (error) {
                alert(`Error loading login logs: ${error.message}`);
            }
        }

        async function backupUserData(userId, email) {
            try {
                const response = await authenticatedFetch(`${API_URL}/admin/users/${userId}/backup`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to backup user data');
                }

                const backup = await response.json();
                const backupStr = JSON.stringify(backup, null, 2);
                const blob = new Blob([backupStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `user_backup_${email}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert(`Backup downloaded for ${email}!`);
            } catch (error) {
                alert(`Error backing up user data: ${error.message}`);
            }
        }

        // Dark mode toggle - default to dark mode
        const darkModeToggle = document.getElementById('darkModeToggle');
        const storedMode = localStorage.getItem('darkMode');
        // Default to dark mode if not set
        const isDarkMode = storedMode === null ? true : storedMode === 'true';
        
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            darkModeToggle.textContent = '‚òÄÔ∏è Light Mode';
            // Save default if not set
            if (storedMode === null) {
                localStorage.setItem('darkMode', 'true');
            }
        }
        
        darkModeToggle.addEventListener('click', () => {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark);
            darkModeToggle.textContent = isDark ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
            // Recreate chart with new dark mode state
            if (debtChart) {
                loadDebtChart();
            }
        });

        // Initialize chart period button state
        initializeChartPeriod();
        
        // Validate authentication and load data on page load
        (async () => {
            // First check if token exists
            if (!checkAuth()) {
                console.log('‚ö†Ô∏è No authentication token found');
                return;
            }
            
            // Validate token by making a test API call
            const isValid = await validateAuth();
            if (isValid) {
                // Token is valid, load data and start updates
                loadData();
                // Start smart updates (WebSocket-only, no timers - like Firebase)
                startSmartUpdates();
            } else {
                // Token was invalid, user has been logged out
                console.log('‚ö†Ô∏è Authentication token invalid - user logged out');
            }
        })();
        
        // No auto-refresh timer - WebSocket handles all real-time updates
        // Stats/contacts/transactions will update when WebSocket sends events
        // Chart is only updated when events change (via WebSocket smart updates)
    </script>
</body>
</html>
