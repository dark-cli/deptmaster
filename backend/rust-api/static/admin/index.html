<n!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debt Tracker - Admin Panel</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #FFFBFE; /* Material 3 light background */
            color: #1C1B1F; /* Material 3 on background */
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: #1C1B1F; /* Material 3 dark background */
            color: #E6E1E5; /* Material 3 on background */
        }

        .header {
            background: #6750A4; /* Material 3 light primary */
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.dark-mode .header {
            background: #6750A4; /* Keep primary color in dark mode too */
        }

        .header h1 {
            font-size: 1.5rem;
            margin: 0;
        }

        .header .dark-mode-toggle {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s;
        }

        .header .dark-mode-toggle:hover {
            background: rgba(255,255,255,0.3);
        }

        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #FFFBFE; /* Material 3 light surface */
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode .stat-card {
            background: #1C1B1F; /* Material 3 dark surface */
        }

        .stat-card h3 {
            font-size: 0.9rem;
            color: #79747E; /* Material 3 light outline */
            margin-bottom: 0.5rem;
        }

        body.dark-mode .stat-card h3 {
            color: #938F99; /* Material 3 dark outline */
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: #6750A4; /* Material 3 light primary */
        }

        /* Event detail modal */
        .event-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .event-modal.active {
            display: flex;
        }

        .event-modal-content {
            background: #FFFBFE;
            border-radius: 12px;
            padding: 2rem;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            position: relative;
        }

        body.dark-mode .event-modal-content {
            background: #1C1B1F;
            color: #E6E1E5;
        }

        .event-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #E7E0EC;
        }

        body.dark-mode .event-modal-header {
            border-bottom-color: #49454F;
        }

        .event-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6750A4;
            padding: 0.5rem;
            line-height: 1;
        }

        .event-modal-close:hover {
            opacity: 0.7;
        }

        .event-modal-field {
            margin-bottom: 1rem;
        }

        .event-modal-field-label {
            font-weight: 600;
            color: #6750A4;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .event-modal-field-value {
            font-size: 1rem;
            color: #1C1B1F;
            word-break: break-word;
        }

        body.dark-mode .event-modal-field-value {
            color: #E6E1E5;
        }

        .event-row {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .event-row:hover {
            background-color: rgba(103, 80, 164, 0.05);
        }

        body.dark-mode .event-row:hover {
            background-color: rgba(103, 80, 164, 0.15);
        }

        body.dark-mode .stat-card .value {
            color: #D0BCFF; /* Material 3 dark primary */
        }

        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #E7E0EC; /* Material 3 light surface variant */
        }

        body.dark-mode .tabs {
            border-bottom-color: #49454F; /* Material 3 dark surface variant */
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1rem;
            color: #79747E; /* Material 3 light outline */
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: color 0.3s;
        }

        body.dark-mode .tab {
            color: #938F99; /* Material 3 dark outline */
        }

        .tab.active {
            color: #6750A4; /* Material 3 light primary */
            border-bottom-color: #6750A4;
        }

        body.dark-mode .tab.active {
            color: #D0BCFF; /* Material 3 dark primary */
            border-bottom-color: #D0BCFF;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .table-container {
            background: #FFFBFE; /* Material 3 light surface */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: background-color 0.3s;
        }

        body.dark-mode .table-container {
            background: #1C1B1F; /* Material 3 dark surface */
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid #E7E0EC; /* Material 3 light surface variant */
        }

        body.dark-mode th,
        body.dark-mode td {
            border-bottom-color: #49454F; /* Material 3 dark surface variant */
        }

        th {
            background: #E7E0EC; /* Material 3 light surface variant */
            font-weight: 600;
            color: #1C1B1F; /* Material 3 on surface */
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode th {
            background: #49454F; /* Material 3 dark surface variant */
            color: #E6E1E5; /* Material 3 on surface */
        }

        tr:hover {
            background: #E7E0EC; /* Material 3 light surface variant */
            transition: background-color 0.2s;
        }

        body.dark-mode tr:hover {
            background: #49454F; /* Material 3 dark surface variant */
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge.success {
            background: rgba(22, 163, 74, 0.1); /* Material 3 light success with opacity */
            color: #16A34A; /* Material 3 light success */
        }

        body.dark-mode .badge.success {
            background: rgba(74, 222, 128, 0.2); /* Material 3 dark success with opacity */
            color: #4ADE80; /* Material 3 dark success */
        }

        .badge.warning {
            background: rgba(245, 158, 11, 0.1); /* Material 3 light warning with opacity */
            color: #F59E0B; /* Material 3 light warning */
        }

        body.dark-mode .badge.warning {
            background: rgba(251, 191, 36, 0.2); /* Material 3 dark warning with opacity */
            color: #FBBF24; /* Material 3 dark warning */
        }

        .badge.error {
            background: rgba(186, 26, 26, 0.1); /* Material 3 light error with opacity */
            color: #BA1A1A; /* Material 3 light error */
        }

        body.dark-mode .badge.error {
            background: rgba(255, 180, 171, 0.2); /* Material 3 dark error with opacity */
            color: #FFB4AB; /* Material 3 dark error */
        }

        .refresh-btn {
            background: #6750A4; /* Material 3 light primary */
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin-bottom: 1rem;
            transition: background-color 0.3s;
        }

        .refresh-btn:hover {
            background: #4F378B; /* Material 3 light primary dark */
        }

        body.dark-mode .refresh-btn {
            background: #6750A4; /* Keep primary in dark mode */
        }

        body.dark-mode .refresh-btn:hover {
            background: #B69DF8; /* Material 3 dark primary dark */
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #79747E; /* Material 3 light outline */
        }

        body.dark-mode .loading {
            color: #938F99; /* Material 3 dark outline */
        }

        .error {
            background: rgba(186, 26, 26, 0.1); /* Material 3 light error with opacity */
            color: #BA1A1A; /* Material 3 light error */
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        body.dark-mode         .error {
            background: rgba(255, 180, 171, 0.2); /* Material 3 dark error with opacity */
            color: #FFB4AB; /* Material 3 dark error */
        }

        /* Dark mode styles for all form inputs and interactive elements */
        body.dark-mode .filter-section {
            background: #1C1B1F !important;
            border-bottom-color: #49454F !important;
        }

        body.dark-mode .form-input,
        body.dark-mode input[type="text"],
        body.dark-mode input[type="date"],
        body.dark-mode input[type="search"],
        body.dark-mode select {
            background: #1C1B1F !important;
            border-color: #49454F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode select option {
            background: #1C1B1F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .form-input::placeholder,
        body.dark-mode input::placeholder {
            color: #938F99 !important;
        }

        body.dark-mode label,
        body.dark-mode .form-label {
            color: #E6E1E5 !important;
        }

        body.dark-mode .pagination-section {
            background: #49454F !important;
            border-bottom-color: #49454F !important;
        }

        body.dark-mode .page-info {
            color: #E6E1E5 !important;
        }

        body.dark-mode .events-count {
            color: #938F99 !important;
        }

        body.dark-mode .btn-secondary {
            background: #625B71 !important;
        }

        body.dark-mode .btn-secondary:hover {
            background: #4A4458 !important;
        }

        body.dark-mode .btn-pagination {
            background: #6750A4 !important;
        }

        body.dark-mode .btn-pagination:hover {
            background: #B69DF8 !important;
        }

        body.dark-mode .btn-pagination:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        body.dark-mode .event-name {
            color: #938F99 !important;
        }

        body.dark-mode .user-id {
            color: #CAC4D0 !important;
        }

        body.dark-mode .comment-box {
            background: rgba(103, 80, 164, 0.2) !important;
            border-left-color: #D0BCFF !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .no-comment {
            color: #938F99 !important;
        }

        body.dark-mode .details-summary {
            color: #938F99 !important;
        }

        body.dark-mode .details-summary-link {
            color: #D0BCFF !important;
        }

        body.dark-mode .details-pre {
            background: #49454F !important;
            border-color: #49454F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .projection-info {
            background: #49454F !important;
            color: #E6E1E5 !important;
        }

        /* Code elements */
        code {
            background: #E7E0EC;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        body.dark-mode code {
            background: #49454F;
            color: #E6E1E5;
        }

        .chart-container {
            background: #FFFBFE;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
            transition: background-color 0.3s;
        }

        body.dark-mode .chart-container {
            background: #1C1B1F;
        }

        .chart-container h2 {
            margin: 0 0 1rem 0;
            color: #1C1B1F;
            font-size: 1.25rem;
            transition: color 0.3s;
        }

        body.dark-mode .chart-container h2 {
            color: #E6E1E5;
        }

        .chart-container canvas {
            background: #FFFBFE;
            transition: background-color 0.3s;
        }

        body.dark-mode .chart-container canvas {
            background: #1C1B1F;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .chart-period-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .chart-period-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #E7E0EC;
            background: #FFFBFE;
            color: #1C1B1F;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        body.dark-mode .chart-period-btn {
            background: #1C1B1F;
            border-color: #49454F;
            color: #E6E1E5;
        }

        .chart-period-btn:hover {
            background: #E7E0EC;
        }

        body.dark-mode .chart-period-btn:hover {
            background: #49454F;
        }

        .chart-period-btn.active {
            background: #6750A4;
            color: white;
            border-color: #6750A4;
        }

        body.dark-mode .chart-period-btn.active {
            background: #6750A4;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Debt Tracker - Admin Panel</h1>
        <button id="darkModeToggle" class="dark-mode-toggle">
            üåô Dark Mode
        </button>
    </div>

    <div class="container">
        <button class="refresh-btn" onclick="loadData()">üîÑ Refresh Data</button>

        <div class="stats" id="stats">
            <div class="stat-card">
                <h3>Total Contacts</h3>
                <div class="value" id="totalContacts">-</div>
            </div>
            <div class="stat-card">
                <h3>Total Transactions</h3>
                <div class="value" id="totalTransactions">-</div>
            </div>
            <div class="stat-card">
                <h3>Total Debt</h3>
                <div class="value" id="totalDebt">-</div>
            </div>
            <div class="stat-card">
                <h3>Pending Reminders</h3>
                <div class="value" id="pendingReminders">-</div>
            </div>
        </div>

        <!-- Debt Over Time Chart -->
        <div class="chart-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2>Total Debt Over Time</h2>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="chart-period-btn" onclick="setChartPeriod('day')" data-period="day">Day</button>
                    <button class="chart-period-btn" onclick="setChartPeriod('week')" data-period="week">Week</button>
                    <button class="chart-period-btn active" onclick="setChartPeriod('month')" data-period="month">Month</button>
                    <button class="chart-period-btn" onclick="setChartPeriod('year')" data-period="year">Year</button>
                </div>
            </div>
            <div style="position: relative; height: 400px;">
                <canvas id="debtChart"></canvas>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('events')">PostgreSQL Events</button>
            <button class="tab" onclick="switchTab('contacts')">Contacts</button>
            <button class="tab" onclick="switchTab('transactions')">Transactions</button>
            <button class="tab" onclick="switchTab('projections')">Projections</button>
        </div>

        <div id="events" class="tab-content active">
            <div class="table-container">
                <!-- Search and Filter Controls -->
                <div class="filter-section" style="padding: 1rem; background: #FFFBFE; border-bottom: 1px solid #E7E0EC;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">üîç Search</label>
                            <input type="text" id="eventSearch" placeholder="Search in comments, names, event types..." 
                                   class="form-input"
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;"
                                   onkeyup="debounceSearch()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Event Type</label>
                            <select id="eventTypeFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                                <option value="">All Event Types</option>
                                <optgroup label="Transaction Events">
                                    <option value="CREATED_TRANSACTION">CREATED_TRANSACTION</option>
                                    <option value="UPDATE_TRANSACTION">UPDATE_TRANSACTION</option>
                                    <option value="DELETE_TRANSACTION">DELETE_TRANSACTION</option>
                                </optgroup>
                                <optgroup label="Contact Events">
                                    <option value="CREATED_CONTACT">CREATED_CONTACT</option>
                                    <option value="UPDATE_CONTACT">UPDATE_CONTACT</option>
                                    <option value="DELETE_CONTACT">DELETE_CONTACT</option>
                                </optgroup>
                                <optgroup label="Other Events">
                                    <option value="UNDO">UNDO</option>
                                </optgroup>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Aggregate Type</label>
                            <select id="aggregateTypeFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                                <option value="">All</option>
                                <option value="contact">Contact</option>
                                <option value="transaction">Transaction</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date From</label>
                            <input type="date" id="dateFromFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date To</label>
                            <input type="date" id="dateToFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <button class="refresh-btn" onclick="applyFilters()" style="margin: 0;">üîç Apply Filters</button>
                        <button onclick="clearFilters()" class="btn-secondary" style="padding: 0.75rem 1.5rem; background: #625B71; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Clear Filters</button>
                        <button class="refresh-btn" onclick="loadEvents()" style="margin: 0; background: #4caf50;">üîÑ Refresh</button>
                        <span id="eventsCount" class="events-count" style="margin-left: auto; color: #79747E;"></span>
                    </div>
                </div>
                
                <!-- Pagination -->
                <div class="pagination-section" style="padding: 1rem; background: #E7E0EC; border-bottom: 1px solid #E7E0EC; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label class="form-label" style="margin-right: 0.5rem; color: #1C1B1F;">Page Size:</label>
                        <select id="pageSize" class="form-input" onchange="applyFilters()" style="padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;">
                            <option value="50">50</option>
                            <option value="100" selected>100</option>
                            <option value="200">200</option>
                            <option value="500">500</option>
                        </select>
                    </div>
                    <div>
                        <button onclick="previousPage()" id="prevBtn" class="btn-pagination" style="padding: 0.5rem 1rem; margin-right: 0.5rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">‚Üê Previous</button>
                        <span id="pageInfo" class="page-info" style="margin: 0 1rem; color: #1C1B1F;">Page 1</span>
                        <button onclick="nextPage()" id="nextBtn" class="btn-pagination" style="padding: 0.5rem 1rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Next ‚Üí</button>
                    </div>
                </div>
                
                <div class="loading" id="eventsLoading">Loading events...</div>
                <table id="eventsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>When</th>
                            <th>Event Type</th>
                            <th>Contact Name</th>
                            <th>Amount</th>
                            <th>Debt</th>
                            <th>User</th>
                            <th>Comment</th>
                            <th>Details</th>
                        </tr>
                    </thead>
                    <tbody id="eventsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="contacts" class="tab-content">
            <div class="table-container">
                <div class="loading" id="contactsLoading">Loading contacts...</div>
                <table id="contactsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Username</th>
                            <th>Email</th>
                            <th>Phone</th>
                            <th>Balance</th>
                            <th>Created At</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="contactsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="transactions" class="tab-content">
            <div class="table-container">
                <div class="loading" id="transactionsLoading">Loading transactions...</div>
                <table id="transactionsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Contact</th>
                            <th>Type</th>
                            <th>Amount</th>
                            <th>Direction</th>
                            <th>Date</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="transactionsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="projections" class="tab-content">
            <div class="table-container">
                <div class="loading" id="projectionsLoading">Loading projections...</div>
                <div id="projectionsContent" style="display: none; padding: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Projection Status</h3>
                    <div id="projectionsInfo"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Detail Modal -->
    <div id="eventModal" class="event-modal" onclick="closeEventModal(event)">
        <div class="event-modal-content" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2>Event Details</h2>
                <button class="event-modal-close" onclick="closeEventModal()">&times;</button>
            </div>
            <div id="eventModalBody"></div>
        </div>
    </div>

    <!-- Event Detail Modal -->
    <div id="eventModal" class="event-modal" onclick="closeEventModal(event)">
        <div class="event-modal-content" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2>Event Details</h2>
                <button class="event-modal-close" onclick="closeEventModal()">&times;</button>
            </div>
            <div id="eventModalBody"></div>
        </div>
    </div>

    <!-- Load configuration (if exists) -->
    <script src="config.js" onerror="console.log('Using default config')"></script>
    <script>
        // Use config from config.js if available, otherwise use defaults
        const API_URL = window.ADMIN_CONFIG?.API_URL || window.location.origin + '/api';
        const WS_URL = window.ADMIN_CONFIG?.WS_URL || ((window.location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + window.location.host + '/ws');
        
        // Smart update state
        let lastEventId = null;
        let wsConnection = null;
        let pollingInterval = null;
        let isUpdating = false;
        let currentTotalDebt = null; // Store current total debt for fallback in events
        
        // Chart state
        let debtChart = null;
        let chartPeriod = 'month'; // Default to month
        let currentChartData = []; // Store chart data for click handler
        
        function setChartPeriod(period) {
            chartPeriod = period;
            // Update button states
            document.querySelectorAll('.chart-period-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-period') === period) {
                    btn.classList.add('active');
                }
            });
            loadDebtChart();
        }
        
        // Initialize chart period button state on page load
        function initializeChartPeriod() {
            setChartPeriod('month'); // Set default to month
        }
        
        async function loadDebtChart() {
            try {
                // Calculate date range based on period (rolling periods: last 24h, 7d, 30d, 365d)
                const now = new Date();
                let periodStart = new Date();
                
                switch (chartPeriod) {
                    case 'day':
                        // Last 24 hours
                        periodStart = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                        break;
                    case 'week':
                        // Last 7 days
                        periodStart = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
                        break;
                    case 'month':
                        // Last 30 days
                        periodStart = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
                        break;
                    case 'year':
                        // Last 365 days
                        periodStart = new Date(now.getTime() - (365 * 24 * 60 * 60 * 1000));
                        break;
                }
                
                // Fetch all events since period start
                const params = new URLSearchParams();
                params.append('date_from', periodStart.toISOString());
                params.append('limit', '10000'); // Get all events in range
                
                const response = await fetch(`${API_URL}/admin/events?${params.toString()}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const events = await response.json();
                
                // Sort events by timestamp
                events.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                
                // Build raw event data: time and total_debt
                // Only include transaction events (CREATED, UPDATED, DELETED) - exclude contact events
                const rawEventData = [];
                
                for (const event of events) {
                    // Filter: only transaction events
                    if (event.aggregate_type !== 'transaction') {
                        continue; // Skip contact events
                    }
                    
                    const eventDataObj = event.event_data || {};
                    const totalDebt = eventDataObj.total_debt;
                    
                    if (totalDebt !== null && totalDebt !== undefined) {
                        const debt = Number(totalDebt);
                        if (!isNaN(debt) && isFinite(debt)) {
                            rawEventData.push({
                                timestamp: new Date(event.created_at).getTime(),
                                debt: debt,
                                event: event // Store full event for tooltip
                            });
                        }
                    }
                }
                
                // If no data points, use current total debt
                if (rawEventData.length === 0 && currentTotalDebt !== null) {
                    rawEventData.push({
                        timestamp: new Date().getTime(),
                        debt: currentTotalDebt
                    });
                }
                
                // Determine time scale configuration based on period
                let timeUnit = 'day';
                let timeStepSize = 1;
                let minorUnit = null;
                let minorStepSize = null;
                let displayFormats = {};
                let intervalMs = 0; // Interval size in milliseconds
                
                switch (chartPeriod) {
                    case 'day':
                        timeUnit = 'hour';
                        timeStepSize = 1;
                        minorUnit = 'minute';
                        minorStepSize = 15;
                        intervalMs = 60 * 60 * 1000; // 1 hour intervals
                        displayFormats = {
                            hour: 'HH:mm',
                            minute: 'mm'
                        };
                        break;
                    case 'week':
                        timeUnit = 'day';
                        timeStepSize = 1;
                        intervalMs = 24 * 60 * 60 * 1000; // 1 day intervals
                        displayFormats = {
                            day: 'EEE d'
                        };
                        break;
                    case 'month':
                        timeUnit = 'week';
                        timeStepSize = 1;
                        minorUnit = 'day';
                        minorStepSize = 1;
                        intervalMs = 24 * 60 * 60 * 1000; // 1 day intervals (average per day)
                        displayFormats = {
                            week: 'MMM d',
                            day: 'd'
                        };
                        break;
                    case 'year':
                        timeUnit = 'month';
                        timeStepSize = 1;
                        minorUnit = 'week';
                        minorStepSize = 1;
                        intervalMs = 7 * 24 * 60 * 60 * 1000; // 1 week intervals (average per week)
                        displayFormats = {
                            month: 'MMM yyyy',
                            week: 'w'
                        };
                        break;
                }
                
                // Set date range - always start from period start, even if no data
                const maxDate = now.getTime();
                const minDate = periodStart.getTime();
                
                // Calculate average debt for each time interval
                const chartData = [];
                const numIntervals = Math.ceil((maxDate - minDate) / intervalMs);
                
                for (let i = 0; i <= numIntervals; i++) {
                    const intervalStart = minDate + (i * intervalMs);
                    const intervalEnd = Math.min(intervalStart + intervalMs, maxDate);
                    const intervalCenter = intervalStart + (intervalMs / 2);
                    
                    // Find all events in this interval
                    const eventsInInterval = rawEventData.filter(evt => 
                        evt.timestamp >= intervalStart && evt.timestamp < intervalEnd
                    );
                    
                    let avgDebt = null;
                    let intervalEvents = []; // Store all events in this interval for tooltip
                    let hasTransactions = false; // Track if this interval has actual transactions
                    
                    if (eventsInInterval.length > 0) {
                        // Calculate average debt for this interval
                        const sum = eventsInInterval.reduce((acc, evt) => acc + evt.debt, 0);
                        avgDebt = sum / eventsInInterval.length;
                        // Store all events in this interval for tooltip
                        intervalEvents = eventsInInterval.map(evt => evt.event).filter(e => e !== null);
                        hasTransactions = true; // This interval has transactions
                    } else {
                        // No events in this interval - find the closest event before this interval
                        const beforeEvents = rawEventData.filter(evt => evt.timestamp < intervalStart);
                        if (beforeEvents.length > 0) {
                            // Use the debt value from the most recent event before this interval
                            const closestBefore = beforeEvents[beforeEvents.length - 1];
                            avgDebt = closestBefore.debt;
                            // Don't store events - this interval has no transactions
                            intervalEvents = [];
                            hasTransactions = false;
                        } else if (rawEventData.length > 0) {
                            // Use the first event's debt if no events before
                            avgDebt = rawEventData[0].debt;
                            intervalEvents = [];
                            hasTransactions = false;
                        } else {
                            // No data at all
                            avgDebt = currentTotalDebt || 0;
                            intervalEvents = [];
                            hasTransactions = false;
                        }
                    }
                    
                    // Store label colors for tooltip (for per-transaction coloring)
                    const labelColors = [];
                    if (hasTransactions && intervalEvents.length > 0) {
                        // First label is average (default color)
                        labelColors.push(null); // null = use default
                        // Then each transaction gets its color
                        intervalEvents.forEach((event) => {
                            const eventData = event.event_data || {};
                            const isGave = eventData.direction === 'lent';
                            labelColors.push(isGave ? '#16A34A' : '#BA1A1A'); // Gave = green, Received = red
                        });
                    }
                    
                    chartData.push({
                        x: intervalCenter,
                        y: avgDebt,
                        events: intervalEvents, // Store all events in interval for tooltip
                        hasTransactions: hasTransactions, // Flag to show/hide point
                        intervalStart: intervalStart, // Store for click handler
                        intervalEnd: intervalEnd, // Store for click handler
                        labelColors: labelColors // Store colors for each label line
                    });
                }
                
                // Store chart data globally for click handler
                currentChartData = chartData;
                
                // Create or update chart
                const ctx = document.getElementById('debtChart');
                const isDark = document.body.classList.contains('dark-mode');
                
                const chartConfig = {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Total Debt (IQD)',
                            data: chartData,
                            borderColor: '#6750A4',
                            backgroundColor: 'rgba(103, 80, 164, 0.1)',
                            borderWidth: 2,
                            fill: false, // No fill - just line connecting actual events
                            tension: 0.4, // Smooth curves passing through actual event points
                            pointRadius: function(context) {
                                // Hide points where no transactions occurred
                                return context.raw?.hasTransactions ? 4 : 0;
                            },
                            pointHoverRadius: function(context) {
                                // Only allow hover on points with transactions
                                return context.raw?.hasTransactions ? 6 : 0;
                            },
                            pointBackgroundColor: '#6750A4',
                            pointBorderColor: isDark ? '#1C1B1F' : '#FFFBFE',
                            pointBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: isDark ? '#E6E1E5' : '#1C1B1F',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                filter: function(tooltipItem) {
                                    // Hide tooltip completely for points without transactions
                                    return tooltipItem.raw?.hasTransactions === true;
                                },
                                backgroundColor: isDark ? '#49454F' : '#FFFBFE',
                                titleColor: isDark ? '#E6E1E5' : '#1C1B1F',
                                bodyColor: isDark ? '#E6E1E5' : '#1C1B1F',
                                borderColor: '#6750A4',
                                borderWidth: 1,
                                padding: 8,
                                titleFont: { size: 12, weight: '600' },
                                bodyFont: { size: 11 },
                                titleSpacing: 4,
                                bodySpacing: 3,
                                displayColors: false,
                                usePointStyle: false,
                                callbacks: {
                                    title: function(context) {
                                        const point = context[0];
                                        const hasTransactions = point.raw?.hasTransactions || false;
                                        
                                        // Only show tooltip if there are transactions in this interval
                                        if (!hasTransactions) {
                                            return null; // Hide tooltip for intervals with no transactions
                                        }
                                        
                                        // Calculate interval size based on chart period
                                        let intervalSize = 0;
                                        switch (chartPeriod) {
                                            case 'day': intervalSize = 60 * 60 * 1000; break; // 1 hour
                                            case 'week': intervalSize = 24 * 60 * 60 * 1000; break; // 1 day
                                            case 'month': intervalSize = 24 * 60 * 60 * 1000; break; // 1 day
                                            case 'year': intervalSize = 7 * 24 * 60 * 60 * 1000; break; // 1 week
                                        }
                                        
                                        // Show interval time range
                                        const intervalStart = new Date(point.parsed.x - (intervalSize / 2));
                                        const intervalEnd = new Date(point.parsed.x + (intervalSize / 2));
                                        
                                        let title = intervalStart.toLocaleString('en-US', {
                                            month: 'short',
                                            day: 'numeric',
                                            hour: 'numeric',
                                            minute: '2-digit'
                                        });
                                        
                                        // Determine format based on interval size
                                        if (intervalSize <= 60 * 60 * 1000) {
                                            // Hour or smaller intervals - show time only for end
                                            title += ' - ' + intervalEnd.toLocaleTimeString('en-US', {
                                                hour: 'numeric',
                                                minute: '2-digit'
                                            });
                                        } else {
                                            // Day or larger intervals - show full date/time
                                            title += ' - ' + intervalEnd.toLocaleString('en-US', {
                                                month: 'short',
                                                day: 'numeric',
                                                hour: 'numeric',
                                                minute: '2-digit'
                                            });
                                        }
                                        
                                        return title;
                                    },
                                    label: function(context) {
                                        const point = context;
                                        const events = point.raw?.events || [];
                                        const hasTransactions = point.raw?.hasTransactions || false;
                                        
                                        // Only show tooltip if there are transactions in this interval
                                        if (!hasTransactions || events.length === 0) {
                                            return null; // Hide tooltip for intervals with no transactions
                                        }
                                        
                                        const debt = Math.round(context.parsed.y);
                                        const lines = [`Avg: ${debt.toLocaleString('en-US')} IQD ‚Ä¢ ${events.length} tx`];
                                        
                                        if (events.length > 0) {
                                            // Show up to 4 transactions in compact format
                                            const maxShow = 4;
                                            const eventsToShow = events.slice(0, maxShow);
                                            
                                            eventsToShow.forEach((event) => {
                                                const eventData = event.event_data || {};
                                                const date = new Date(event.created_at);
                                                const timeStr = date.toLocaleTimeString('en-US', {
                                                    hour: 'numeric',
                                                    minute: '2-digit'
                                                });
                                                
                                                let txLine = `${timeStr} `;
                                                
                                                if (eventData.amount !== null && eventData.amount !== undefined) {
                                                    const amount = Number(eventData.amount);
                                                    // Standardization: Received (owed) = -, Gave (lent) = +
                                                    const sign = eventData.direction === 'lent' ? '+' : '-';
                                                    const currency = eventData.currency || 'IQD';
                                                    txLine += `${sign}${Math.round(amount).toLocaleString('en-US')} ${currency}`;
                                                } else {
                                                    txLine += event.event_type;
                                                }
                                                
                                                if (contactNameCache[eventData.contact_id]) {
                                                    txLine += ` ‚Ä¢ ${contactNameCache[eventData.contact_id]}`;
                                                }
                                                
                                                lines.push(txLine);
                                            });
                                            
                                            if (events.length > maxShow) {
                                                lines.push(`+${events.length - maxShow} more`);
                                            }
                                        }
                                        
                                        return lines;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: timeUnit,
                                    stepSize: timeStepSize,
                                    displayFormats: displayFormats,
                                    tooltipFormat: 'PPpp'
                                },
                                min: minDate,
                                max: maxDate,
                                ticks: {
                                    color: isDark ? '#938F99' : '#79747E',
                                    maxRotation: 45,
                                    minRotation: 45,
                                    source: 'auto',
                                    autoSkip: true
                                },
                                grid: {
                                    color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                                    drawOnChartArea: true
                                },
                                ...(minorUnit && minorStepSize ? {
                                    minor: {
                                        unit: minorUnit,
                                        stepSize: minorStepSize,
                                        display: true
                                    },
                                    grid: {
                                        ...(isDark ? {
                                            color: 'rgba(255, 255, 255, 0.05)'
                                        } : {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }),
                                        drawOnChartArea: true,
                                        drawTicks: false
                                    }
                                } : {})
                            },
                            y: {
                                reverse: true, // Zero at bottom
                                ticks: {
                                    color: isDark ? '#938F99' : '#79747E',
                                    callback: function(value) {
                                        return Math.round(value).toLocaleString('en-US') + ' IQD';
                                    }
                                },
                                grid: {
                                    color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        onClick: function(event, elements) {
                            if (elements.length > 0) {
                                const element = elements[0];
                                const point = currentChartData[element.index];
                                
                                // Only filter if this point has transactions
                                if (point && point.hasTransactions) {
                                    // Format dates for input fields (YYYY-MM-DD)
                                    const formatDate = (timestamp) => {
                                        const date = new Date(timestamp);
                                        const year = date.getFullYear();
                                        const month = String(date.getMonth() + 1).padStart(2, '0');
                                        const day = String(date.getDate()).padStart(2, '0');
                                        return `${year}-${month}-${day}`;
                                    };
                                    
                                    // Set filter dates using stored interval boundaries
                                    document.getElementById('dateFromFilter').value = formatDate(point.intervalStart);
                                    document.getElementById('dateToFilter').value = formatDate(point.intervalEnd);
                                    
                                    // Switch to Events tab if not already there
                                    switchTab('events');
                                    
                                    // Apply filters to show events in this time period
                                    applyFilters();
                                }
                            }
                        }
                    }
                };
                
                if (debtChart) {
                    // Destroy and recreate chart to ensure all colors update properly
                    debtChart.destroy();
                    debtChart = null;
                }
                
                // Create new chart with current dark mode state
                debtChart = new Chart(ctx, chartConfig);
            } catch (error) {
                console.error('Error loading debt chart:', error);
            }
        }

        async function loadData() {
            // Load stats first to populate currentTotalDebt
            await loadStats();
            // Then load events (which will use currentTotalDebt as fallback)
            await Promise.all([
                loadEvents(),
                loadContacts(),
                loadTransactions(),
                loadProjections(),
                loadDebtChart()
            ]);
        }

        async function loadStats() {
            try {
                const [contacts, transactions, totalDebtResponse] = await Promise.all([
                    fetch(`${API_URL}/admin/contacts`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    }),
                    fetch(`${API_URL}/admin/transactions`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    }),
                    fetch(`${API_URL}/admin/total-debt`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    })
                ]);

                // Use total_debt from latest event (more efficient and solid)
                const totalDebt = totalDebtResponse.total_debt || 0;

                const formatAmount = (amt) => {
                    return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                };

                document.getElementById('totalContacts').textContent = contacts.length;
                document.getElementById('totalTransactions').textContent = transactions.length;
                const totalDebtText = `${formatAmount(totalDebt)} IQD`;
                document.getElementById('totalDebt').textContent = totalDebtText;
                currentTotalDebt = totalDebt; // Store for fallback in events
                document.getElementById('pendingReminders').textContent = '0'; // TODO
            } catch (error) {
                console.error('Error loading stats:', error);
                document.getElementById('totalContacts').textContent = 'Error';
                document.getElementById('totalTransactions').textContent = 'Error';
            }
        }

        // Events log state
        let currentPage = 0;
        let pageSize = 100;
        let searchTimeout = null;

        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentPage = 0; // Reset to first page on new search
                applyFilters();
            }, 500);
        }

        function clearFilters() {
            document.getElementById('eventSearch').value = '';
            document.getElementById('eventTypeFilter').value = '';
            document.getElementById('aggregateTypeFilter').value = '';
            document.getElementById('dateFromFilter').value = '';
            document.getElementById('dateToFilter').value = '';
            currentPage = 0;
            applyFilters();
        }

        function previousPage() {
            if (currentPage > 0) {
                currentPage--;
                applyFilters();
            }
        }

        function nextPage() {
            currentPage++;
            applyFilters();
        }

        function applyFilters() {
            pageSize = parseInt(document.getElementById('pageSize').value) || 100;
            loadEvents();
        }

        async function loadEvents(silent = false) {
            if (isUpdating && !silent) return; // Prevent concurrent updates unless silent
            isUpdating = true;
            
            const loading = document.getElementById('eventsLoading');
            const table = document.getElementById('eventsTable');
            const body = document.getElementById('eventsBody');
            const countSpan = document.getElementById('eventsCount');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            // Build query parameters
            const params = new URLSearchParams();
            params.append('limit', pageSize.toString());
            params.append('offset', (currentPage * pageSize).toString());
            
            const search = document.getElementById('eventSearch').value.trim();
            if (search) {
                params.append('search', search);
            }
            
            const eventType = document.getElementById('eventTypeFilter').value;
            if (eventType) {
                params.append('event_type', eventType);
            }
            
            const aggregateType = document.getElementById('aggregateTypeFilter').value;
            if (aggregateType) {
                params.append('aggregate_type', aggregateType);
            }
            
            const dateFrom = document.getElementById('dateFromFilter').value;
            if (dateFrom) {
                params.append('date_from', dateFrom + 'T00:00:00');
            }
            
            const dateTo = document.getElementById('dateToFilter').value;
            if (dateTo) {
                params.append('date_to', dateTo + 'T23:59:59');
            }

            try {
                if (!silent) {
                    loading.style.display = 'block';
                    table.style.display = 'none';
                }
                
                const response = await fetch(`${API_URL}/admin/events?${params.toString()}`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const events = await response.json();

                // Pre-load contact names for all events
                const contactIds = new Set();
                const undoneEventIds = new Set();
                const deletedContactIds = new Set(); // Track deleted contact IDs to look up from other events
                
                // First pass: collect all contact IDs and cache names from event_data
                events.forEach(event => {
                    const eventData = event.event_data || {};
                    
                    // Cache contact names from aggregate_id for all contact events
                    if (event.aggregate_type === 'contact') {
                        const name = eventData.name;
                        if (name && event.aggregate_id) {
                            contactNameCache[event.aggregate_id] = name;
                        }
                        // For DELETE events, also cache deleted contact name using aggregate_id
                        if (eventData.deleted_contact && typeof eventData.deleted_contact === 'object' && 
                            eventData.deleted_contact !== null && eventData.deleted_contact.name && event.aggregate_id) {
                            contactNameCache[event.aggregate_id] = eventData.deleted_contact.name;
                        } else if ((event.event_type === 'CONTACT_DELETED' || event.event_type.includes('DELETE')) && event.aggregate_id) {
                            // Track deleted contact IDs to look up from other events
                            deletedContactIds.add(event.aggregate_id);
                        }
                    } else if (event.aggregate_type === 'transaction') {
                        const contactId = eventData.contact_id;
                        if (contactId) contactIds.add(contactId);
                        // For DELETE events, also get contact from deleted_transaction
                        if (eventData.deleted_transaction && typeof eventData.deleted_transaction === 'object' && 
                            eventData.deleted_transaction !== null && eventData.deleted_transaction.contact_id) {
                            contactIds.add(eventData.deleted_transaction.contact_id);
                        }
                    }
                    // Handle CONTACT_DELETED and TRANSACTION_DELETED event types
                    if (event.event_type === 'CONTACT_DELETED' || event.event_type === 'TRANSACTION_DELETED') {
                        if (eventData.deleted_contact && typeof eventData.deleted_contact === 'object' && 
                            eventData.deleted_contact !== null && eventData.deleted_contact.name && event.aggregate_id) {
                            contactNameCache[event.aggregate_id] = eventData.deleted_contact.name;
                        } else if (event.event_type === 'CONTACT_DELETED' && event.aggregate_id) {
                            deletedContactIds.add(event.aggregate_id);
                        }
                        if (eventData.deleted_transaction && typeof eventData.deleted_transaction === 'object' && 
                            eventData.deleted_transaction !== null && eventData.deleted_transaction.contact_id) {
                            contactIds.add(eventData.deleted_transaction.contact_id);
                        }
                    }
                    // Collect UNDO event IDs to fetch undone events
                    if (event.event_type === 'UNDO' && eventData.undone_event_id) {
                        undoneEventIds.add(eventData.undone_event_id);
                    }
                });
                
                // Second pass: for deleted contacts without names, try to find them in other events in this batch
                if (deletedContactIds.size > 0) {
                    events.forEach(event => {
                        // Look for CREATED or UPDATE events for the deleted contacts
                        if ((event.event_type === 'CREATED' || event.event_type === 'CREATED_CONTACT' || 
                             event.event_type.includes('CREATE') || event.event_type.includes('UPDATE')) &&
                            event.aggregate_type === 'contact' && event.aggregate_id && 
                            deletedContactIds.has(event.aggregate_id)) {
                            const name = event.event_data?.name;
                            if (name) {
                                contactNameCache[event.aggregate_id] = name;
                            }
                        }
                    });
                }
                
                // Fetch missing contact names from contacts endpoint
                if (contactIds.size > 0) {
                    try {
                        const contactsResponse = await fetch(`${API_URL}/admin/contacts`);
                        if (contactsResponse.ok) {
                            const contacts = await contactsResponse.json();
                            contacts.forEach(contact => {
                                if (contactIds.has(contact.id)) {
                                    contactNameCache[contact.id] = contact.name;
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error pre-loading contacts:', e);
                    }
                }
                
                // For deleted contacts without names, fetch from CREATED events
                // Also collect transaction aggregate_ids for DELETE transaction events
                const deletedTransactionIds = new Set();
                events.forEach(event => {
                    if ((event.event_type === 'DELETED' || event.event_type.includes('DELETE')) && 
                        event.aggregate_type === 'transaction' && event.aggregate_id) {
                        deletedTransactionIds.add(event.aggregate_id);
                    }
                });
                
                if (deletedContactIds.size > 0 || deletedTransactionIds.size > 0) {
                    try {
                        // Fetch CREATED events for contacts
                        if (deletedContactIds.size > 0) {
                            const createdContactEventsResponse = await fetch(`${API_URL}/admin/events?limit=10000&event_type=CREATED&aggregate_type=contact`);
                            if (createdContactEventsResponse.ok) {
                                const createdContactEvents = await createdContactEventsResponse.json();
                                createdContactEvents.forEach(evt => {
                                    if (evt.aggregate_type === 'contact' && evt.aggregate_id && 
                                        deletedContactIds.has(evt.aggregate_id) && 
                                        evt.event_data?.name) {
                                        contactNameCache[evt.aggregate_id] = evt.event_data.name;
                                    }
                                });
                            }
                        }
                        
                        // Fetch CREATED events for transactions to get their contact_ids
                        if (deletedTransactionIds.size > 0) {
                            const createdTransactionEventsResponse = await fetch(`${API_URL}/admin/events?limit=10000&event_type=CREATED&aggregate_type=transaction`);
                            if (createdTransactionEventsResponse.ok) {
                                const createdTransactionEvents = await createdTransactionEventsResponse.json();
                                createdTransactionEvents.forEach(evt => {
                                    if (evt.aggregate_type === 'transaction' && evt.aggregate_id && 
                                        deletedTransactionIds.has(evt.aggregate_id) && 
                                        evt.event_data?.contact_id) {
                                        contactIds.add(evt.event_data.contact_id);
                                    }
                                });
                                // Re-fetch contacts for these transaction contact IDs
                                if (contactIds.size > 0) {
                                    const contactsResponse = await fetch(`${API_URL}/admin/contacts`);
                                    if (contactsResponse.ok) {
                                        const contacts = await contactsResponse.json();
                                        contacts.forEach(contact => {
                                            if (contactIds.has(contact.id)) {
                                                contactNameCache[contact.id] = contact.name;
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error fetching names from CREATED events:', e);
                    }
                }
                
                // Fetch undone events to show what was undone
                if (undoneEventIds.size > 0) {
                    try {
                        // Fetch all events to find the undone ones (they might be in a different page)
                        const allEventsResponse = await fetch(`${API_URL}/admin/events?limit=10000&offset=0`);
                        if (allEventsResponse.ok) {
                            const allEvents = await allEventsResponse.json();
                            const newContactIds = new Set();
                            
                            allEvents.forEach(evt => {
                                if (undoneEventIds.has(evt.event_id)) {
                                    undoneEventsCache[evt.event_id] = evt;
                                    // The undone event is usually a DELETED event, so we need to get the name from CREATED events
                                    if (evt.aggregate_type === 'contact' && evt.aggregate_id) {
                                        const name = evt.event_data?.name;
                                        if (name) {
                                            contactNameCache[evt.aggregate_id] = name;
                                        } else {
                                            // If no name in event_data (DELETED event), we need to find CREATED event
                                            deletedContactIds.add(evt.aggregate_id);
                                        }
                                    }
                                    // For undone transactions, get contact_id from CREATED transaction event
                                    if (evt.aggregate_type === 'transaction' && evt.aggregate_id) {
                                        const contactId = evt.event_data?.contact_id;
                                        if (contactId) {
                                            newContactIds.add(contactId);
                                        } else {
                                            // If no contact_id (DELETED event), we need to find CREATED event
                                            deletedTransactionIds.add(evt.aggregate_id);
                                        }
                                    }
                                }
                            });
                            
                            // Add new contact IDs to the main set
                            newContactIds.forEach(id => contactIds.add(id));
                            
                            // Re-fetch contacts if we found new ones
                            if (contactIds.size > 0) {
                                const contactsResponse = await fetch(`${API_URL}/admin/contacts`);
                                if (contactsResponse.ok) {
                                    const contacts = await contactsResponse.json();
                                    contacts.forEach(contact => {
                                        if (contactIds.has(contact.id)) {
                                            contactNameCache[contact.id] = contact.name;
                                        }
                                    });
                                }
                            }
                            
                            // For undone contacts without names, fetch from CREATED events
                            if (deletedContactIds.size > 0) {
                                const createdEventsResponse = await fetch(`${API_URL}/admin/events?limit=10000&event_type=CREATED&aggregate_type=contact`);
                                if (createdEventsResponse.ok) {
                                    const createdEvents = await createdEventsResponse.json();
                                    createdEvents.forEach(evt => {
                                        if (evt.aggregate_type === 'contact' && evt.aggregate_id && 
                                            deletedContactIds.has(evt.aggregate_id) && 
                                            evt.event_data?.name) {
                                            contactNameCache[evt.aggregate_id] = evt.event_data.name;
                                        }
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error pre-loading undone events:', e);
                    }
                }

                if (!silent) {
                loading.style.display = 'none';
                }
                table.style.display = 'table';
                
                // Update count
                countSpan.textContent = `Showing ${events.length} event(s)`;
                
                // Update pagination
                pageInfo.textContent = `Page ${currentPage + 1}`;
                prevBtn.disabled = currentPage === 0;
                prevBtn.style.opacity = currentPage === 0 ? '0.5' : '1';
                prevBtn.style.cursor = currentPage === 0 ? 'not-allowed' : 'pointer';
                nextBtn.disabled = events.length < pageSize;
                nextBtn.style.opacity = events.length < pageSize ? '0.5' : '1';
                nextBtn.style.cursor = events.length < pageSize ? 'not-allowed' : 'pointer';
                
                // Smooth DOM update - only replace if content changed
                const newContent = renderEvents(events);
                const currentContent = body.innerHTML;
                
                if (newContent !== currentContent) {
                    // Add fade effect for smooth update
                    if (silent) {
                        body.style.transition = 'opacity 0.2s';
                        body.style.opacity = '0.7';
                        setTimeout(() => {
                            body.innerHTML = newContent;
                            body.style.opacity = '1';
                        }, 100);
                    } else {
                        body.innerHTML = newContent;
                    }
                }
            } catch (error) {
                if (!silent) {
                loading.innerHTML = `<div class="error">Error loading events: ${error.message}</div>`;
                }
                console.error('Error:', error);
            } finally {
                isUpdating = false;
            }
        }
        
        // Extract event rendering to separate function for reuse
        // Cache for contact names (to avoid repeated lookups)
        let contactNameCache = {};
        // Cache for undone events (to show what was undone)
        let undoneEventsCache = {};
        
        async function getContactName(contactId) {
            if (!contactId) return null;
            if (contactNameCache[contactId]) return contactNameCache[contactId];
            
            try {
                const response = await fetch(`${API_URL}/admin/contacts`);
                if (response.ok) {
                    const contacts = await response.json();
                    const contact = contacts.find(c => c.id === contactId);
                    if (contact) {
                        contactNameCache[contactId] = contact.name;
                        return contact.name;
                    }
                }
            } catch (e) {
                console.error('Error fetching contact name:', e);
            }
            return null;
        }
        
        // Event modal functions
        function showEventModal(event) {
            const modal = document.getElementById('eventModal');
            const body = document.getElementById('eventModalBody');
            
            const eventData = event.event_data || {};
            const contactId = eventData.contact_id || null;
            const contactName = contactId ? (contactNameCache[contactId] || 'Unknown') : null;
            
            let html = '';
            
            // Basic Info
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Event ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(event.event_id) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Event Type</div><div class="event-modal-field-value">' + escapeHtml(event.event_type) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Aggregate Type</div><div class="event-modal-field-value">' + escapeHtml(event.aggregate_type) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Aggregate ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(event.aggregate_id) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Created At</div><div class="event-modal-field-value">' + formatDateTime(event.created_at) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">User</div><div class="event-modal-field-value">' + escapeHtml(eventData.username || event.user_email || event.user_id) + '</div></div>';
            
            // Handle UNDO events
            if (event.event_type === 'UNDO' && eventData.undone_event_id) {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Event ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(eventData.undone_event_id) + '</div></div>';
                if (undoneEventsCache[eventData.undone_event_id]) {
                    const undoneEvent = undoneEventsCache[eventData.undone_event_id];
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Event Type</div><div class="event-modal-field-value">' + escapeHtml(undoneEvent.event_type) + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Aggregate Type</div><div class="event-modal-field-value">' + escapeHtml(undoneEvent.aggregate_type) + '</div></div>';
                    if (undoneEvent.aggregate_type === 'contact') {
                        const undoneName = undoneEvent.event_data?.name || 'Unknown';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Contact</div><div class="event-modal-field-value">' + escapeHtml(undoneName) + '</div></div>';
                    } else if (undoneEvent.aggregate_type === 'transaction') {
                        const undoneContactId = undoneEvent.event_data?.contact_id;
                        const undoneContactName = undoneContactId ? (contactNameCache[undoneContactId] || 'Unknown Contact') : 'Unknown Contact';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Transaction Contact</div><div class="event-modal-field-value">' + escapeHtml(undoneContactName) + '</div></div>';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Transaction Amount</div><div class="event-modal-field-value">' + (undoneEvent.event_data?.amount ? (undoneEvent.event_data.amount.toLocaleString('en-US') + ' ' + (undoneEvent.event_data.currency || 'IQD')) : 'N/A') + '</div></div>';
                        html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Transaction Direction</div><div class="event-modal-field-value">' + escapeHtml(undoneEvent.event_data?.direction || 'N/A') + '</div></div>';
                    }
                } else {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Undone Event</div><div class="event-modal-field-value" style="color: #938F99;">Not loaded (event may be outside current page)</div></div>';
                }
            }
            // Handle DELETE events
            else if (event.event_type.includes('DELETE') || event.event_type.includes('DELETED')) {
                if (eventData.deleted_contact) {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label" style="color: #BA1A1A; font-weight: 700;">Deleted Contact</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Name</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.name || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Username</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.username || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Phone</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.phone || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Email</div><div class="event-modal-field-value">' + escapeHtml(eventData.deleted_contact.email || 'N/A') + '</div></div>';
                }
                if (eventData.deleted_transaction) {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label" style="color: #BA1A1A; font-weight: 700;">Deleted Transaction</div></div>';
                    const deletedTx = eventData.deleted_transaction;
                    const deletedContactId = deletedTx.contact_id;
                    const deletedContactName = deletedContactId ? (contactNameCache[deletedContactId] || 'Unknown Contact') : 'Unknown Contact';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact</div><div class="event-modal-field-value">' + escapeHtml(deletedContactName) + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Type</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.type || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Direction</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.direction || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Amount</div><div class="event-modal-field-value">' + (deletedTx.amount ? deletedTx.amount.toLocaleString('en-US') + ' ' + (deletedTx.currency || 'IQD') : 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Description</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.description || 'N/A') + '</div></div>';
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Transaction Date</div><div class="event-modal-field-value">' + escapeHtml(deletedTx.transaction_date || 'N/A') + '</div></div>';
                }
            }
            // Contact Info
            else if (event.aggregate_type === 'contact') {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact Name</div><div class="event-modal-field-value">' + escapeHtml(eventData.name || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Username</div><div class="event-modal-field-value">' + escapeHtml(eventData.username || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Phone</div><div class="event-modal-field-value">' + escapeHtml(eventData.phone || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Email</div><div class="event-modal-field-value">' + escapeHtml(eventData.email || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Notes</div><div class="event-modal-field-value">' + escapeHtml(eventData.notes || 'N/A') + '</div></div>';
            } else if (event.aggregate_type === 'transaction') {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact</div><div class="event-modal-field-value">' + escapeHtml(contactName || 'Unknown') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Type</div><div class="event-modal-field-value">' + escapeHtml(eventData.type || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Direction</div><div class="event-modal-field-value">' + escapeHtml(eventData.direction || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Amount</div><div class="event-modal-field-value">' + (eventData.amount ? eventData.amount.toLocaleString('en-US') + ' ' + (eventData.currency || 'IQD') : 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Transaction Date</div><div class="event-modal-field-value">' + escapeHtml(eventData.transaction_date || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Due Date</div><div class="event-modal-field-value">' + escapeHtml(eventData.due_date || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Description</div><div class="event-modal-field-value">' + escapeHtml(eventData.description || 'N/A') + '</div></div>';
            }
            
            // Total Debt
            if (eventData.total_debt !== null && eventData.total_debt !== undefined) {
                const debt = Number(eventData.total_debt);
                if (!isNaN(debt) && isFinite(debt)) {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Total Debt (after this event)</div><div class="event-modal-field-value" style="font-weight: 600; color: #6750A4; font-size: 1.1rem;">' + Math.round(debt).toLocaleString('en-US') + ' IQD</div></div>';
                }
            }
            
            // Comment
            if (eventData.comment) {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Comment</div><div class="event-modal-field-value">' + escapeHtml(eventData.comment) + '</div></div>';
            }
            
            // Full Event Data
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Full Event Data (JSON)</div><pre class="details-pre" style="padding: 1rem; border-radius: 4px; overflow: auto; max-height: 300px; font-size: 0.85rem; margin-top: 0.5rem;">' + escapeHtml(JSON.stringify(event, null, 2)) + '</pre></div>';
            
            body.innerHTML = html;
            modal.classList.add('active');
        }
        
        function closeEventModal(e) {
            if (e && e.target.id !== 'eventModal' && !e.target.classList.contains('event-modal-close')) {
                return;
            }
            const modal = document.getElementById('eventModal');
            modal.classList.remove('active');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function renderEvents(events) {
            return events.map(event => {
                    // event.event_data is already a parsed JSON object from the API
                    const eventData = event.event_data || {};
                    const comment = eventData.comment || eventData.Comment || null;
                    const name = eventData.name || eventData.Name || null;
                    const amount = eventData.amount || null;
                    const direction = eventData.direction || null;
                    const type = eventData.type || null;
                    const description = eventData.description || null;
                    const contactId = eventData.contact_id || null;
                    const username = eventData.username || eventData.Username || null;
                    // Get total_debt from event_data (this is the value saved in the database at event execution time)
                    let totalDebt = null;
                    
                    // eventData is already a parsed JSON object from the database
                    if (eventData && typeof eventData === 'object') {
                        // Check for total_debt (snake_case - as stored in database)
                        if (eventData.hasOwnProperty('total_debt')) {
                            totalDebt = eventData.total_debt;
                        }
                        // Also check for totalDebt (camelCase - just in case)
                        else if (eventData.hasOwnProperty('totalDebt')) {
                            totalDebt = eventData.totalDebt;
                        }
                    }
                    
                    // Convert to number if needed (handle string, number, or other types)
                    if (totalDebt !== null && totalDebt !== undefined) {
                        if (typeof totalDebt === 'number') {
                            // Already a number, check if valid
                            if (isNaN(totalDebt) || !isFinite(totalDebt)) {
                                totalDebt = null;
                            }
                        } else if (typeof totalDebt === 'string') {
                            const parsed = parseFloat(totalDebt);
                            if (!isNaN(parsed) && isFinite(parsed)) {
                                totalDebt = parsed;
                            } else {
                                totalDebt = null;
                            }
                        } else {
                            // Try to convert other types to number
                            const num = Number(totalDebt);
                            if (!isNaN(num) && isFinite(num)) {
                                totalDebt = num;
                            } else {
                                totalDebt = null;
                            }
                        }
                    }
                    
                    // Handle DELETE events - extract deleted item info
                    let deletedContactName = null;
                    let deletedTransactionInfo = null;
                    // deleted_contact is an object (not an array), and might be null
                    // Check if it exists and has a name property
                    if (eventData.deleted_contact) {
                        if (typeof eventData.deleted_contact === 'object' && eventData.deleted_contact !== null) {
                            deletedContactName = eventData.deleted_contact.name || null;
                        } else if (typeof eventData.deleted_contact === 'string') {
                            // In case it's serialized as a string
                            try {
                                const parsed = JSON.parse(eventData.deleted_contact);
                                deletedContactName = parsed.name || null;
                            } catch (e) {
                                // Ignore parse errors
                            }
                        }
                    }
                    // deleted_transaction is also an object (not an array), and might be null
                    if (eventData.deleted_transaction) {
                        if (typeof eventData.deleted_transaction === 'object' && eventData.deleted_transaction !== null) {
                            const deletedTx = eventData.deleted_transaction;
                            const deletedContactId = deletedTx.contact_id; // This is a string UUID
                            deletedTransactionInfo = {
                                contactId: deletedContactId,
                                amount: deletedTx.amount,
                                direction: deletedTx.direction,
                                description: deletedTx.description
                            };
                        } else if (typeof eventData.deleted_transaction === 'string') {
                            // In case it's serialized as a string
                            try {
                                const parsed = JSON.parse(eventData.deleted_transaction);
                                deletedTransactionInfo = {
                                    contactId: parsed.contact_id,
                                    amount: parsed.amount,
                                    direction: parsed.direction,
                                    description: parsed.description
                                };
                            } catch (e) {
                                // Ignore parse errors
                            }
                        }
                    }
                    
                    // Handle UNDO events - will be populated later
                    let undoneEventInfo = null;
                    if (event.event_type === 'UNDO' && eventData.undone_event_id) {
                        // We'll fetch this in loadEvents
                        undoneEventInfo = { undoneEventId: eventData.undone_event_id };
                    }
                    
                    // Determine contact name - show name instead of ID
                    let contactName = null;
                    
                    // For UNDO events, show what was undone (check this first)
                    if (event.event_type === 'UNDO' || event.event_type.toUpperCase() === 'UNDO') {
                        // Try to get undone event info from cache
                        const undoneEventId = eventData.undone_event_id;
                        if (undoneEventId && undoneEventsCache[undoneEventId]) {
                            const undoneEvent = undoneEventsCache[undoneEventId];
                            // The undone event is usually a DELETED event, so we need to get the name from CREATED event
                            if (undoneEvent.aggregate_type === 'contact') {
                                // Get contact name from CREATED event using aggregate_id
                                const undoneContactId = undoneEvent.aggregate_id;
                                const undoneName = contactNameCache[undoneContactId];
                                if (undoneName) {
                                    contactName = `Undone: ${undoneName}`;
                                } else {
                                    // Try to find CREATED event in current batch
                                    const createdEvent = events.find(e => 
                                        e.aggregate_type === 'contact' && 
                                        e.aggregate_id === undoneContactId &&
                                        (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                    );
                                    if (createdEvent && createdEvent.event_data?.name) {
                                        contactName = `Undone: ${createdEvent.event_data.name}`;
                                        contactNameCache[undoneContactId] = createdEvent.event_data.name;
                                    } else {
                                        contactName = `Undone: ${undoneContactId.substring(0, 8)}...`;
                                    }
                                }
                            } else if (undoneEvent.aggregate_type === 'transaction') {
                                // For undone transaction, get contact from the transaction's CREATED event
                                const undoneTransactionId = undoneEvent.aggregate_id;
                                // Try to find the CREATED event for this transaction to get contact_id
                                let undoneContactId = null;
                                // Look in the events we already have
                                const createdTxEvent = events.find(e => 
                                    e.aggregate_type === 'transaction' && 
                                    e.aggregate_id === undoneTransactionId &&
                                    (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                );
                                if (createdTxEvent && createdTxEvent.event_data?.contact_id) {
                                    undoneContactId = createdTxEvent.event_data.contact_id;
                                }
                                
                                const undoneContactName = undoneContactId ? (contactNameCache[undoneContactId] || 'Unknown Contact') : 'Unknown Contact';
                                const undoneAmount = undoneEvent.event_data?.amount;
                                const undoneDirection = undoneEvent.event_data?.direction;
                                if (undoneAmount !== null && undoneAmount !== undefined) {
                                    const sign = undoneDirection === 'lent' ? '+' : '-';
                                    contactName = `Undone: ${undoneContactName} (${sign}${Math.round(Number(undoneAmount)).toLocaleString('en-US')} IQD)`;
                                } else {
                                    contactName = `Undone: ${undoneContactName}`;
                                }
                            } else {
                                contactName = 'Undone Event';
                            }
                        } else if (event.aggregate_id) {
                            // Fallback: try to get from aggregate_id (which is the contact/transaction ID)
                            const name = contactNameCache[event.aggregate_id];
                            if (name) {
                                contactName = `Undone: ${name}`;
                            } else {
                                // Try to find CREATED event in current batch
                                const createdEvent = events.find(e => 
                                    e.aggregate_id === event.aggregate_id &&
                                    (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                );
                                if (createdEvent) {
                                    if (createdEvent.aggregate_type === 'contact' && createdEvent.event_data?.name) {
                                        contactName = `Undone: ${createdEvent.event_data.name}`;
                                    } else if (createdEvent.aggregate_type === 'transaction' && createdEvent.event_data?.contact_id) {
                                        const txContactId = createdEvent.event_data.contact_id;
                                        const txContactName = contactNameCache[txContactId] || 'Unknown Contact';
                                        contactName = `Undone: ${txContactName}`;
                                    } else {
                                        contactName = 'Undone Event';
                                    }
                                } else {
                                    contactName = 'Undone Event';
                                }
                            }
                        } else {
                            contactName = 'Undone Event';
                        }
                    }
                    // For DELETE events, use deleted item info
                    else if (event.event_type.includes('DELETE') || event.event_type.includes('DELETED') || 
                             event.event_type === 'CONTACT_DELETED' || event.event_type === 'TRANSACTION_DELETED') {
                        if (event.aggregate_type === 'contact' || event.event_type === 'CONTACT_DELETED') {
                            // For DELETE contact events, use deleted_contact name
                            // Priority: deleted_contact.name > aggregate_id from cache > name from event_data
                            if (deletedContactName) {
                                contactName = deletedContactName;
                                // Also cache it for future use
                                if (event.aggregate_id) {
                                    contactNameCache[event.aggregate_id] = deletedContactName;
                                }
                            } else if (event.aggregate_id) {
                                // Try to get from cache first
                                contactName = contactNameCache[event.aggregate_id] || null;
                                // If not in cache, the contact loading step will try to fetch it
                                if (!contactName) {
                                    contactName = 'Unknown';
                                }
                            } else {
                                contactName = name || 'Unknown';
                            }
                        } else if (event.aggregate_type === 'transaction' || event.event_type === 'TRANSACTION_DELETED' || event.event_type === 'DELETED') {
                            // For DELETE transaction events, use deleted_transaction contact
                            // Priority: deleted_transaction.contact_id > contact_id from event_data > CREATED event lookup
                            if (deletedTransactionInfo && deletedTransactionInfo.contactId) {
                                const deletedContactId = deletedTransactionInfo.contactId;
                                contactName = contactNameCache[deletedContactId] || null;
                                if (!contactName) {
                                    // Will be fetched in the contact loading step
                                    contactName = 'Unknown Contact';
                                }
                            } else if (contactId) {
                                contactName = contactNameCache[contactId] || 'Unknown Contact';
                            } else if (event.aggregate_id) {
                                // Try to get contact_id from CREATED transaction event
                                const createdTxEvent = events.find(e => 
                                    e.aggregate_type === 'transaction' && 
                                    e.aggregate_id === event.aggregate_id &&
                                    (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                );
                                if (createdTxEvent && createdTxEvent.event_data?.contact_id) {
                                    const txContactId = createdTxEvent.event_data.contact_id;
                                    contactName = contactNameCache[txContactId] || 'Unknown Contact';
                                } else {
                                    contactName = 'Unknown Contact';
                                }
                            } else {
                                contactName = 'Unknown Contact';
                            }
                        }
                    }
                    // For regular events
                    else if (event.aggregate_type === 'contact') {
                        contactName = name || contactNameCache[event.aggregate_id] || 'Unknown';
                    } else if (event.aggregate_type === 'transaction') {
                        if (contactId) {
                            contactName = contactNameCache[contactId] || 'Unknown Contact';
                        } else {
                            contactName = contactNameCache[event.aggregate_id] || 'Unknown Contact';
                        }
                    }
                    
                    // User display - show username only (no ID)
                    const userDisplay = username || event.user_email || 'N/A';
                    
                    // Format total debt - show the value saved in database at event execution time
                    let totalDebtDisplay = 'N/A';
                    if (totalDebt !== null && totalDebt !== undefined) {
                        const num = Number(totalDebt);
                        if (!isNaN(num) && isFinite(num)) {
                            totalDebtDisplay = `${Math.round(num).toLocaleString('en-US')} IQD`;
                        }
                    }
                    
                    // Get event type badge color
                    let badgeClass = 'badge';
                    const eventTypeUpper = event.event_type.toUpperCase();
                    if (eventTypeUpper.includes('CREATED') || eventTypeUpper.includes('CREATE')) {
                        badgeClass += ' success';
                    } else if (eventTypeUpper.includes('UPDATED') || eventTypeUpper.includes('UPDATE')) {
                        badgeClass += ' warning';
                    } else if (eventTypeUpper.includes('DELETED') || eventTypeUpper.includes('DELETE')) {
                        // DELETE events use warning badge (same as UPDATE) to match other events
                        badgeClass += ' warning';
                    } else if (eventTypeUpper === 'UNDO') {
                        badgeClass += ' warning';
                    }
                    
                    // Format event type for display - make it more specific
                    let displayEventType = event.event_type;
                    
                    // Handle UNDO events specially - show what's being undone
                    if (event.event_type === 'UNDO' || event.event_type.toUpperCase() === 'UNDO') {
                        const undoneEventId = eventData.undone_event_id;
                        if (undoneEventId && undoneEventsCache[undoneEventId]) {
                            const undoneEvent = undoneEventsCache[undoneEventId];
                            const undoneType = undoneEvent.event_type || 'Event';
                            const undoneAggregate = undoneEvent.aggregate_type || '';
                            
                            // Format: "Undo [Aggregate] [Action]"
                            // e.g., "Undo Contact Delete", "Undo Transaction Update"
                            let undoneAction = '';
                            if (undoneType.includes('DELETE') || undoneType.includes('DELETED')) {
                                undoneAction = 'Delete';
                            } else if (undoneType.includes('UPDATE') || undoneType.includes('UPDATED')) {
                                undoneAction = 'Update';
                            } else if (undoneType.includes('CREATE') || undoneType.includes('CREATED')) {
                                undoneAction = 'Create';
                            } else {
                                undoneAction = undoneType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            }
                            
                            const aggregateName = undoneAggregate.charAt(0).toUpperCase() + undoneAggregate.slice(1);
                            displayEventType = `Undo ${aggregateName} ${undoneAction}`;
                        } else {
                            displayEventType = 'Undo';
                        }
                    }
                    // If event type is generic (CREATED, UPDATED, DELETED), make it specific based on aggregate_type
                    else {
                        const genericTypes = ['CREATED', 'UPDATED', 'DELETED', 'CREATE', 'UPDATE', 'DELETE'];
                        const isGeneric = genericTypes.some(gt => event.event_type.toUpperCase() === gt || 
                                                                  event.event_type.toUpperCase().includes(gt));
                        
                        // Check if event type already has aggregate in it (e.g., CONTACT_DELETED, TRANSACTION_DELETED)
                        const eventTypeUpper = event.event_type.toUpperCase();
                        if (eventTypeUpper.includes('_CONTACT') || eventTypeUpper.includes('_TRANSACTION')) {
                            // Event type already includes aggregate, just format it
                            displayEventType = event.event_type;
                        } else if (isGeneric && event.aggregate_type) {
                            // Convert to specific format: CREATED_TRANSACTION, UPDATE_TRANSACTION, DELETE_TRANSACTION, etc.
                            const action = event.event_type.toUpperCase();
                            let specificAction = '';
                            
                            if (action.includes('CREATED') || action.includes('CREATE')) {
                                specificAction = 'CREATED';
                            } else if (action.includes('UPDATED') || action.includes('UPDATE')) {
                                specificAction = 'UPDATE';
                            } else if (action.includes('DELETED') || action.includes('DELETE')) {
                                specificAction = 'DELETE';
                            } else {
                                specificAction = action;
                            }
                            
                            const aggregateUpper = event.aggregate_type.toUpperCase();
                            displayEventType = `${specificAction}_${aggregateUpper}`;
                        }
                        
                        // Format for display (replace underscores with spaces, capitalize words)
                        displayEventType = displayEventType
                            .replace(/_/g, ' ')
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                            .join(' ');
                    }
                    
                    // contactName is already determined above - use it directly
                    
                    // Format amount display with +/- and colors
                    let amountDisplay = '-';
                    
                    // For UNDO events, show undone transaction amount or contact balance impact (check this first)
                    if (event.event_type === 'UNDO' || event.event_type.toUpperCase() === 'UNDO') {
                        const undoneEventId = eventData.undone_event_id;
                        if (undoneEventId && undoneEventsCache[undoneEventId]) {
                            const undoneEvent = undoneEventsCache[undoneEventId];
                            // If undoing a transaction, show the transaction amount
                            if (undoneEvent.aggregate_type === 'transaction') {
                                let undoneAmount = null;
                                let undoneDirection = null;
                                
                                // First try to get from undone event's event_data (for UPDATE events)
                                if (undoneEvent.event_data?.amount !== null && undoneEvent.event_data?.amount !== undefined) {
                                    undoneAmount = undoneEvent.event_data.amount;
                                    undoneDirection = undoneEvent.event_data.direction;
                                }
                                // If undone event is DELETE, try to get from deleted_transaction
                                else if (undoneEvent.event_data?.deleted_transaction) {
                                    undoneAmount = undoneEvent.event_data.deleted_transaction.amount;
                                    undoneDirection = undoneEvent.event_data.deleted_transaction.direction;
                                }
                                
                                // If still no amount, try to find CREATED transaction event in current batch
                                if ((undoneAmount === null || undoneAmount === undefined) && undoneEvent.aggregate_id) {
                                    const createdTxEvent = events.find(e => 
                                        e.aggregate_type === 'transaction' && 
                                        e.aggregate_id === undoneEvent.aggregate_id &&
                                        (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                                    );
                                    if (createdTxEvent && createdTxEvent.event_data?.amount) {
                                        undoneAmount = createdTxEvent.event_data.amount;
                                        undoneDirection = createdTxEvent.event_data.direction || 'owed';
                                    }
                                }
                                
                                // Display the amount if we found it
                                if (undoneAmount !== null && undoneAmount !== undefined) {
                                    const amountNum = Number(undoneAmount);
                                    if (!isNaN(amountNum) && isFinite(amountNum)) {
                                        const sign = (undoneDirection || 'owed') === 'lent' ? '+' : '-';
                                        const amountColor = (undoneDirection || 'owed') === 'lent' ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                        amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} IQD</span>`;
                                    }
                                }
                            }
                            // If undoing a contact delete, calculate the net balance impact from total_debt change
                            else if (undoneEvent.aggregate_type === 'contact') {
                                // Find the DELETE event for this contact to get the total_debt before deletion
                                const deleteEvent = events.find(e => 
                                    e.aggregate_type === 'contact' &&
                                    e.aggregate_id === undoneEvent.aggregate_id &&
                                    (e.event_type === 'DELETED' || e.event_type.includes('DELETE'))
                                );
                                
                                if (deleteEvent && deleteEvent.event_data?.total_debt !== null && deleteEvent.event_data?.total_debt !== undefined &&
                                    totalDebt !== null && totalDebt !== undefined) {
                                    const deleteTotalDebt = Number(deleteEvent.event_data.total_debt);
                                    const undoTotalDebt = Number(totalDebt);
                                    
                                    if (!isNaN(deleteTotalDebt) && !isNaN(undoTotalDebt)) {
                                        // The difference is the net impact of restoring the contact
                                        const netImpact = undoTotalDebt - deleteTotalDebt;
                                        
                                        if (netImpact !== 0) {
                                            const sign = netImpact > 0 ? '+' : '-';
                                            const amountColor = netImpact > 0 ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                            amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.abs(Math.round(netImpact)).toLocaleString('en-US')} IQD</span>`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // For DELETE contact events, calculate the net balance impact from total_debt change
                    else if ((event.event_type === 'DELETED' || event.event_type.includes('DELETE')) && 
                             event.aggregate_type === 'contact') {
                        // Find the event before this DELETE to get total_debt before deletion
                        const currentIndex = events.findIndex(e => e.event_id === event.event_id);
                        if (currentIndex > 0) {
                            const previousEvent = events[currentIndex - 1];
                            const previousTotalDebt = previousEvent.event_data?.total_debt;
                            
                            if (previousTotalDebt !== null && previousTotalDebt !== undefined &&
                                totalDebt !== null && totalDebt !== undefined) {
                                const beforeTotalDebt = Number(previousTotalDebt);
                                const afterTotalDebt = Number(totalDebt);
                                
                                if (!isNaN(beforeTotalDebt) && !isNaN(afterTotalDebt)) {
                                    // The difference is the net impact of deleting the contact
                                    const netImpact = afterTotalDebt - beforeTotalDebt;
                                    
                                    if (netImpact !== 0) {
                                        const sign = netImpact > 0 ? '+' : '-';
                                        const amountColor = netImpact > 0 ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                        amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.abs(Math.round(netImpact)).toLocaleString('en-US')} IQD</span>`;
                                    }
                                }
                            }
                        }
                    }
                    // For DELETE transaction events, show deleted transaction amount
                    else if (deletedTransactionInfo && deletedTransactionInfo.amount !== null && deletedTransactionInfo.amount !== undefined) {
                        const amountNum = Number(deletedTransactionInfo.amount);
                        if (!isNaN(amountNum) && isFinite(amountNum)) {
                            const sign = deletedTransactionInfo.direction === 'lent' ? '+' : '-';
                            const amountColor = deletedTransactionInfo.direction === 'lent' ? 'color: #16A34A;' : 'color: #BA1A1A;';
                            amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} IQD</span>`;
                        }
                    }
                    // For DELETE transaction events without deleted_transaction data, try to get from CREATED event
                    else if ((event.event_type === 'DELETED' || event.event_type.includes('DELETE')) && 
                             event.aggregate_type === 'transaction' && event.aggregate_id) {
                        // Try to find CREATED transaction event to get amount
                        const createdTxEvent = events.find(e => 
                            e.aggregate_type === 'transaction' && 
                            e.aggregate_id === event.aggregate_id &&
                            (e.event_type === 'CREATED' || e.event_type.includes('CREATE'))
                        );
                        if (createdTxEvent && createdTxEvent.event_data?.amount) {
                            const amountNum = Number(createdTxEvent.event_data.amount);
                            if (!isNaN(amountNum) && isFinite(amountNum)) {
                                const direction = createdTxEvent.event_data.direction || 'owed';
                                const sign = direction === 'lent' ? '+' : '-';
                                const amountColor = direction === 'lent' ? 'color: #16A34A;' : 'color: #BA1A1A;';
                                amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} IQD</span>`;
                            }
                        }
                    }
                    // For regular transaction events
                    else if (event.aggregate_type === 'transaction' && amount !== null) {
                        const amountNum = Number(amount);
                        if (!isNaN(amountNum) && isFinite(amountNum)) {
                            const currency = eventData.currency || 'IQD';
                            // Standardization: Received (owed) = red (negative) = -, Gave (lent) = green (positive) = +
                            const isReceived = direction === 'owed'; // owed = Received
                            const isGave = direction === 'lent'; // lent = Gave
                            const sign = isGave ? '+' : '-'; // Gave = +, Received = -
                            const amountColor = isGave ? 'color: #16A34A;' : 'color: #BA1A1A;'; // Gave = green, Received = red
                            amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} ${currency}</span>`;
                        }
                    }
                    
                    // Store event data as JSON for modal (properly escaped)
                    const eventJson = JSON.stringify(event).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    
                    return `
                        <tr class="event-row" onclick='showEventModal(${JSON.stringify(event)})' data-event-id="${event.event_id}">
                            <td style="white-space: nowrap; font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${formatDateTime(event.created_at)}
                            </td>
                            <td style="padding: 0.4rem 0.5rem;">
                                <span class="${badgeClass}" style="font-size: 0.7rem;">${displayEventType}</span>
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${contactName || 'Unknown'}
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${amountDisplay !== '-' ? amountDisplay : '-'}
                            </td>
                            <td style="font-size: 0.75rem; font-weight: 600; color: #6750A4; white-space: nowrap; padding: 0.4rem 0.5rem;">
                                ${totalDebtDisplay}
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${userDisplay}
                            </td>
                            <td style="max-width: 150px; font-size: 0.7rem; padding: 0.4rem 0.5rem;">
                                ${comment ? `<div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${comment.replace(/"/g, '&quot;')}">${comment.substring(0, 30)}${comment.length > 30 ? '...' : ''}</div>` : '<em style="color: #938F99;">-</em>'}
                            </td>
                            <td style="font-size: 0.7rem; padding: 0.4rem 0.5rem;">
                                <span style="color: #6750A4; cursor: pointer;">View</span>
                            </td>
                        </tr>
                    `;
            }).join('');
        }
        
        // Smart update system - only updates when there are changes
        function startSmartUpdates() {
            // First, get the latest event ID
            fetch(`${API_URL}/admin/events/latest`)
                .then(r => r.json())
                .then(data => {
                    lastEventId = data.latest_event_id;
                })
                .catch(err => console.error('Error getting latest event ID:', err));
            
            // Try WebSocket first (real-time)
            try {
                wsConnection = new WebSocket(WS_URL);
                
                wsConnection.onopen = () => {
                    console.log('‚úÖ WebSocket connected for real-time updates');
                };
                
                wsConnection.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        // When we receive ANY WebSocket event, immediately check for updates
                        // This ensures hot updates without delay
                        checkForUpdates();
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                    }
                };
                
                wsConnection.onerror = (error) => {
                    console.log('WebSocket error, will reconnect:', error);
                    // Auto-reconnect after short delay (like Firebase)
                    setTimeout(() => {
                        startSmartUpdates();
                    }, 1000);
                };
                
                wsConnection.onclose = () => {
                    console.log('WebSocket closed, will reconnect');
                    // Auto-reconnect after short delay (like Firebase)
                    setTimeout(() => {
                        startSmartUpdates();
                    }, 1000);
                };
            } catch (e) {
                console.log('WebSocket not available, using polling:', e);
                startPolling();
            }
        }
        
        // No polling - WebSocket handles all updates (like Firebase)
        // Only reconnect WebSocket if it fails
        function startPolling() {
            // No polling timer - WebSocket is the only update mechanism
            // If WebSocket fails, it will reconnect automatically
            console.log('WebSocket-only mode: No polling timers');
        }
        
        // Check for updates (used by WebSocket and polling)
        async function checkForUpdates() {
            try {
                const response = await fetch(`${API_URL}/admin/events/latest`);
                const data = await response.json();
                
                if (data.latest_event_id !== null && data.latest_event_id !== lastEventId) {
                    // There are new events! Update everything immediately (like Firebase)
                    console.log('üîÑ New events detected, updating all data...');
                    lastEventId = data.latest_event_id;
                    // Refresh all data immediately when WebSocket detects changes
                    await Promise.all([
                        loadStats(),
                        loadContacts(),
                        loadTransactions(),
                        loadEvents(true), // true = silent update
                        loadDebtChart()
                    ]);
                }
            } catch (err) {
                console.error('Error checking for updates:', err);
            }
        }

        async function loadContacts() {
            const loading = document.getElementById('contactsLoading');
            const table = document.getElementById('contactsTable');
            const body = document.getElementById('contactsBody');

            try {
                const response = await fetch(`${API_URL}/admin/contacts`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const contacts = await response.json();

                loading.style.display = 'none';
                table.style.display = 'table';
                body.innerHTML = contacts.map(contact => {
                    // Balance is stored as whole units (IQD), format with commas
                    const formatAmount = (amt) => {
                        return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };
                    const balance = contact.balance ? `${formatAmount(contact.balance)} IQD` : '0 IQD';
                    return `
                    <tr>
                        <td>${contact.id.substring(0, 8)}...</td>
                        <td>${contact.name}</td>
                        <td>${contact.username ? '@' + contact.username : '-'}</td>
                        <td>${contact.email || '-'}</td>
                        <td>${contact.phone || '-'}</td>
                        <td>${balance}</td>
                        <td>${formatDateTime(contact.created_at)}</td>
                        <td><span class="badge ${contact.is_deleted ? 'error' : 'success'}">${contact.is_deleted ? 'Deleted' : 'Active'}</span></td>
                    </tr>
                `;
                }).join('');
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading contacts: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        async function loadTransactions() {
            const loading = document.getElementById('transactionsLoading');
            const table = document.getElementById('transactionsTable');
            const body = document.getElementById('transactionsBody');

            try {
                const response = await fetch(`${API_URL}/admin/transactions`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const transactions = await response.json();
                const contactsResponse = await fetch(`${API_URL}/admin/contacts`);
                let contacts = [];
                if (contactsResponse.ok) {
                    contacts = await contactsResponse.json();
                }
                const contactMap = new Map(contacts.map(c => [c.id, c.name]));

                loading.style.display = 'none';
                table.style.display = 'table';
                body.innerHTML = transactions.map(t => {
                    // Amount is stored as whole units (IQD), format with commas
                    const formatAmount = (amt) => {
                        return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };
                    const amount = t.type === 'money' ? `${formatAmount(t.amount)} IQD` : `${t.amount} item(s)`;
                    return `
                        <tr>
                            <td>${t.id.substring(0, 8)}...</td>
                            <td>${contactMap.get(t.contact_id) || 'Unknown'}</td>
                            <td>${t.type}</td>
                            <td>${amount}</td>
                            <td><span class="badge ${t.direction === 'owed' ? 'error' : 'success'}">${t.direction}</span></td>
                            <td>${new Date(t.transaction_date).toLocaleDateString()}</td>
                            <td><span class="badge success">Active</span></td>
                        </tr>
                    `;
                }).join('');
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading transactions: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        async function loadProjections() {
            const loading = document.getElementById('projectionsLoading');
            const content = document.getElementById('projectionsContent');
            const info = document.getElementById('projectionsInfo');

            try {
                const response = await fetch(`${API_URL}/admin/projections/status`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const status = await response.json();

                loading.style.display = 'none';
                content.style.display = 'block';
                info.innerHTML = `
                    <div class="projection-info" style="background: #E7E0EC; padding: 1rem; border-radius: 4px; margin-bottom: 1rem; color: #1C1B1F;">
                        <strong>Last Event ID:</strong> ${status.last_event_id || 'N/A'}<br>
                        <strong>Projections Updated:</strong> ${status.projections_updated || 'N/A'}<br>
                        <strong>Last Update:</strong> ${status.last_update ? new Date(status.last_update).toLocaleString() : 'N/A'}
                    </div>
                    <pre class="details-pre" style="background: #E7E0EC; padding: 1rem; border-radius: 4px; overflow: auto; color: #1C1B1F;">${JSON.stringify(status, null, 2)}</pre>
                `;
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading projections: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        function formatDateTime(dateStr) {
            if (!dateStr) return 'N/A';
            try {
                // Handle both ISO strings and NaiveDateTime format
                const date = new Date(dateStr);
                return date.toLocaleString();
            } catch (e) {
                return dateStr;
            }
        }


        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Find and activate the clicked tab button
            document.querySelectorAll('.tab').forEach(tab => {
                if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(tabName)) {
                    tab.classList.add('active');
                }
            });
            document.getElementById(tabName).classList.add('active');
        }

        // Dark mode toggle - default to dark mode
        const darkModeToggle = document.getElementById('darkModeToggle');
        const storedMode = localStorage.getItem('darkMode');
        // Default to dark mode if not set
        const isDarkMode = storedMode === null ? true : storedMode === 'true';
        
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            darkModeToggle.textContent = '‚òÄÔ∏è Light Mode';
            // Save default if not set
            if (storedMode === null) {
                localStorage.setItem('darkMode', 'true');
            }
        }
        
        darkModeToggle.addEventListener('click', () => {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark);
            darkModeToggle.textContent = isDark ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
            // Recreate chart with new dark mode state
            if (debtChart) {
                loadDebtChart();
            }
        });

        // Initialize chart period button state
        initializeChartPeriod();
        
        // Load data on page load
        loadData();
        
        // Start smart updates (WebSocket-only, no timers - like Firebase)
        startSmartUpdates();
        
        // No auto-refresh timer - WebSocket handles all real-time updates
        // Stats/contacts/transactions will update when WebSocket sends events
        // Chart is only updated when events change (via WebSocket smart updates)
    </script>
</body>
</html>
