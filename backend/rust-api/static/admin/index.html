<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debt Tracker - Admin Panel</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #FFFBFE; /* Material 3 light background */
            color: #1C1B1F; /* Material 3 on background */
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: #1C1B1F; /* Material 3 dark background */
            color: #E6E1E5; /* Material 3 on background */
        }

        .header {
            background: #6750A4; /* Material 3 light primary */
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.dark-mode .header {
            background: #6750A4; /* Keep primary color in dark mode too */
        }

        .header h1 {
            font-size: 1.5rem;
            margin: 0;
        }

        .header .dark-mode-toggle {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s;
        }

        .header .dark-mode-toggle:hover {
            background: rgba(255,255,255,0.3);
        }

        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #FFFBFE; /* Material 3 light surface */
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode .stat-card {
            background: #1C1B1F; /* Material 3 dark surface */
        }

        .stat-card h3 {
            font-size: 0.9rem;
            color: #79747E; /* Material 3 light outline */
            margin-bottom: 0.5rem;
        }

        body.dark-mode .stat-card h3 {
            color: #938F99; /* Material 3 dark outline */
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: #6750A4; /* Material 3 light primary */
        }

        /* Event detail modal */
        .event-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .event-modal.active {
            display: flex;
        }

        .event-modal-content {
            background: #FFFBFE;
            border-radius: 12px;
            padding: 2rem;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            position: relative;
        }

        body.dark-mode .event-modal-content {
            background: #1C1B1F;
            color: #E6E1E5;
        }

        .event-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #E7E0EC;
        }

        body.dark-mode .event-modal-header {
            border-bottom-color: #49454F;
        }

        .event-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6750A4;
            padding: 0.5rem;
            line-height: 1;
        }

        .event-modal-close:hover {
            opacity: 0.7;
        }

        .event-modal-field {
            margin-bottom: 1rem;
        }

        .event-modal-field-label {
            font-weight: 600;
            color: #6750A4;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .event-modal-field-value {
            font-size: 1rem;
            color: #1C1B1F;
            word-break: break-word;
        }

        body.dark-mode .event-modal-field-value {
            color: #E6E1E5;
        }

        .event-row {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .event-row:hover {
            background-color: rgba(103, 80, 164, 0.05);
        }

        body.dark-mode .event-row:hover {
            background-color: rgba(103, 80, 164, 0.15);
        }

        body.dark-mode .stat-card .value {
            color: #D0BCFF; /* Material 3 dark primary */
        }

        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #E7E0EC; /* Material 3 light surface variant */
        }

        body.dark-mode .tabs {
            border-bottom-color: #49454F; /* Material 3 dark surface variant */
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1rem;
            color: #79747E; /* Material 3 light outline */
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: color 0.3s;
        }

        body.dark-mode .tab {
            color: #938F99; /* Material 3 dark outline */
        }

        .tab.active {
            color: #6750A4; /* Material 3 light primary */
            border-bottom-color: #6750A4;
        }

        body.dark-mode .tab.active {
            color: #D0BCFF; /* Material 3 dark primary */
            border-bottom-color: #D0BCFF;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .table-container {
            background: #FFFBFE; /* Material 3 light surface */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: background-color 0.3s;
        }

        body.dark-mode .table-container {
            background: #1C1B1F; /* Material 3 dark surface */
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid #E7E0EC; /* Material 3 light surface variant */
        }

        body.dark-mode th,
        body.dark-mode td {
            border-bottom-color: #49454F; /* Material 3 dark surface variant */
        }

        th {
            background: #E7E0EC; /* Material 3 light surface variant */
            font-weight: 600;
            color: #1C1B1F; /* Material 3 on surface */
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode th {
            background: #49454F; /* Material 3 dark surface variant */
            color: #E6E1E5; /* Material 3 on surface */
        }

        tr:hover {
            background: #E7E0EC; /* Material 3 light surface variant */
            transition: background-color 0.2s;
        }

        body.dark-mode tr:hover {
            background: #49454F; /* Material 3 dark surface variant */
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge.success {
            background: rgba(22, 163, 74, 0.1); /* Material 3 light success with opacity */
            color: #16A34A; /* Material 3 light success */
        }

        body.dark-mode .badge.success {
            background: rgba(74, 222, 128, 0.2); /* Material 3 dark success with opacity */
            color: #4ADE80; /* Material 3 dark success */
        }

        .badge.warning {
            background: rgba(245, 158, 11, 0.1); /* Material 3 light warning with opacity */
            color: #F59E0B; /* Material 3 light warning */
        }

        body.dark-mode .badge.warning {
            background: rgba(251, 191, 36, 0.2); /* Material 3 dark warning with opacity */
            color: #FBBF24; /* Material 3 dark warning */
        }

        .badge.error {
            background: rgba(186, 26, 26, 0.1); /* Material 3 light error with opacity */
            color: #BA1A1A; /* Material 3 light error */
        }

        body.dark-mode .badge.error {
            background: rgba(255, 180, 171, 0.2); /* Material 3 dark error with opacity */
            color: #FFB4AB; /* Material 3 dark error */
        }

        .refresh-btn {
            background: #6750A4; /* Material 3 light primary */
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin-bottom: 1rem;
            transition: background-color 0.3s;
        }

        .refresh-btn:hover {
            background: #4F378B; /* Material 3 light primary dark */
        }

        body.dark-mode .refresh-btn {
            background: #6750A4; /* Keep primary in dark mode */
        }

        body.dark-mode .refresh-btn:hover {
            background: #B69DF8; /* Material 3 dark primary dark */
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #79747E; /* Material 3 light outline */
        }

        body.dark-mode .loading {
            color: #938F99; /* Material 3 dark outline */
        }

        .error {
            background: rgba(186, 26, 26, 0.1); /* Material 3 light error with opacity */
            color: #BA1A1A; /* Material 3 light error */
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        body.dark-mode         .error {
            background: rgba(255, 180, 171, 0.2); /* Material 3 dark error with opacity */
            color: #FFB4AB; /* Material 3 dark error */
        }

        /* Dark mode styles for all form inputs and interactive elements */
        body.dark-mode .filter-section {
            background: #1C1B1F !important;
            border-bottom-color: #49454F !important;
        }

        body.dark-mode .form-input,
        body.dark-mode input[type="text"],
        body.dark-mode input[type="date"],
        body.dark-mode input[type="search"],
        body.dark-mode select {
            background: #1C1B1F !important;
            border-color: #49454F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode select option {
            background: #1C1B1F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .form-input::placeholder,
        body.dark-mode input::placeholder {
            color: #938F99 !important;
        }

        body.dark-mode label,
        body.dark-mode .form-label {
            color: #E6E1E5 !important;
        }

        body.dark-mode .pagination-section {
            background: #49454F !important;
            border-bottom-color: #49454F !important;
        }

        body.dark-mode .page-info {
            color: #E6E1E5 !important;
        }

        body.dark-mode .events-count {
            color: #938F99 !important;
        }

        body.dark-mode .btn-secondary {
            background: #625B71 !important;
        }

        body.dark-mode .btn-secondary:hover {
            background: #4A4458 !important;
        }

        body.dark-mode .btn-pagination {
            background: #6750A4 !important;
        }

        body.dark-mode .btn-pagination:hover {
            background: #B69DF8 !important;
        }

        body.dark-mode .btn-pagination:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        body.dark-mode .event-name {
            color: #938F99 !important;
        }

        body.dark-mode .user-id {
            color: #CAC4D0 !important;
        }

        body.dark-mode .comment-box {
            background: rgba(103, 80, 164, 0.2) !important;
            border-left-color: #D0BCFF !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .no-comment {
            color: #938F99 !important;
        }

        body.dark-mode .details-summary {
            color: #938F99 !important;
        }

        body.dark-mode .details-summary-link {
            color: #D0BCFF !important;
        }

        body.dark-mode .details-pre {
            background: #49454F !important;
            border-color: #49454F !important;
            color: #E6E1E5 !important;
        }

        body.dark-mode .projection-info {
            background: #49454F !important;
            color: #E6E1E5 !important;
        }

        /* Code elements */
        code {
            background: #E7E0EC;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        body.dark-mode code {
            background: #49454F;
            color: #E6E1E5;
        }

        .chart-container {
            background: #FFFBFE;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
            transition: background-color 0.3s;
        }

        body.dark-mode .chart-container {
            background: #1C1B1F;
        }

        .chart-container h2 {
            margin: 0 0 1rem 0;
            color: #1C1B1F;
            font-size: 1.25rem;
            transition: color 0.3s;
        }

        body.dark-mode .chart-container h2 {
            color: #E6E1E5;
        }

        .chart-container canvas {
            background: #FFFBFE;
            transition: background-color 0.3s;
        }

        body.dark-mode .chart-container canvas {
            background: #1C1B1F;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .chart-period-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .chart-period-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #E7E0EC;
            background: #FFFBFE;
            color: #1C1B1F;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        body.dark-mode .chart-period-btn {
            background: #1C1B1F;
            border-color: #49454F;
            color: #E6E1E5;
        }

        .chart-period-btn:hover {
            background: #E7E0EC;
        }

        body.dark-mode .chart-period-btn:hover {
            background: #49454F;
        }

        .chart-period-btn.active {
            background: #6750A4;
            color: white;
            border-color: #6750A4;
        }

        body.dark-mode .chart-period-btn.active {
            background: #6750A4;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Debt Tracker - Admin Panel</h1>
        <button id="darkModeToggle" class="dark-mode-toggle">
            üåô Dark Mode
        </button>
    </div>

    <div class="container">
        <button class="refresh-btn" onclick="loadData()">üîÑ Refresh Data</button>

        <div class="stats" id="stats">
            <div class="stat-card">
                <h3>Total Contacts</h3>
                <div class="value" id="totalContacts">-</div>
            </div>
            <div class="stat-card">
                <h3>Total Transactions</h3>
                <div class="value" id="totalTransactions">-</div>
            </div>
            <div class="stat-card">
                <h3>Total Debt</h3>
                <div class="value" id="totalDebt">-</div>
            </div>
            <div class="stat-card">
                <h3>Pending Reminders</h3>
                <div class="value" id="pendingReminders">-</div>
            </div>
        </div>

        <!-- Debt Over Time Chart -->
        <div class="chart-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2>Total Debt Over Time</h2>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="chart-period-btn" onclick="setChartPeriod('day')" data-period="day">Day</button>
                    <button class="chart-period-btn" onclick="setChartPeriod('week')" data-period="week">Week</button>
                    <button class="chart-period-btn active" onclick="setChartPeriod('month')" data-period="month">Month</button>
                    <button class="chart-period-btn" onclick="setChartPeriod('year')" data-period="year">Year</button>
                </div>
            </div>
            <div style="position: relative; height: 400px;">
                <canvas id="debtChart"></canvas>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('events')">PostgreSQL Events</button>
            <button class="tab" onclick="switchTab('contacts')">Contacts</button>
            <button class="tab" onclick="switchTab('transactions')">Transactions</button>
            <button class="tab" onclick="switchTab('projections')">Projections</button>
        </div>

        <div id="events" class="tab-content active">
            <div class="table-container">
                <!-- Search and Filter Controls -->
                <div class="filter-section" style="padding: 1rem; background: #FFFBFE; border-bottom: 1px solid #E7E0EC;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">üîç Search</label>
                            <input type="text" id="eventSearch" placeholder="Search in comments, names, event types..." 
                                   class="form-input"
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;"
                                   onkeyup="debounceSearch()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Event Type</label>
                            <select id="eventTypeFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                                <option value="">All Event Types</option>
                                <option value="CREATED">CREATED</option>
                                <option value="UPDATED">UPDATED</option>
                                <option value="DELETED">DELETED</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Aggregate Type</label>
                            <select id="aggregateTypeFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                                <option value="">All</option>
                                <option value="contact">Contact</option>
                                <option value="transaction">Transaction</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date From</label>
                            <input type="date" id="dateFromFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                        </div>
                        <div>
                            <label class="form-label" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1C1B1F;">Date To</label>
                            <input type="date" id="dateToFilter" class="form-input" style="width: 100%; padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;" onchange="applyFilters()">
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <button class="refresh-btn" onclick="applyFilters()" style="margin: 0;">üîç Apply Filters</button>
                        <button onclick="clearFilters()" class="btn-secondary" style="padding: 0.75rem 1.5rem; background: #625B71; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Clear Filters</button>
                        <button class="refresh-btn" onclick="loadEvents()" style="margin: 0; background: #4caf50;">üîÑ Refresh</button>
                        <span id="eventsCount" class="events-count" style="margin-left: auto; color: #79747E;"></span>
                    </div>
                </div>
                
                <!-- Pagination -->
                <div class="pagination-section" style="padding: 1rem; background: #E7E0EC; border-bottom: 1px solid #E7E0EC; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label class="form-label" style="margin-right: 0.5rem; color: #1C1B1F;">Page Size:</label>
                        <select id="pageSize" class="form-input" onchange="applyFilters()" style="padding: 0.5rem; border: 1px solid #E7E0EC; border-radius: 4px; background: #FFFBFE; color: #1C1B1F;">
                            <option value="50">50</option>
                            <option value="100" selected>100</option>
                            <option value="200">200</option>
                            <option value="500">500</option>
                        </select>
                    </div>
                    <div>
                        <button onclick="previousPage()" id="prevBtn" class="btn-pagination" style="padding: 0.5rem 1rem; margin-right: 0.5rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">‚Üê Previous</button>
                        <span id="pageInfo" class="page-info" style="margin: 0 1rem; color: #1C1B1F;">Page 1</span>
                        <button onclick="nextPage()" id="nextBtn" class="btn-pagination" style="padding: 0.5rem 1rem; background: #6750A4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;">Next ‚Üí</button>
                    </div>
                </div>
                
                <div class="loading" id="eventsLoading">Loading events...</div>
                <table id="eventsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>When</th>
                            <th>Event Type</th>
                            <th>Aggregate</th>
                            <th>Amount</th>
                            <th>Debt</th>
                            <th>User</th>
                            <th>Comment</th>
                            <th>Details</th>
                        </tr>
                    </thead>
                    <tbody id="eventsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="contacts" class="tab-content">
            <div class="table-container">
                <div class="loading" id="contactsLoading">Loading contacts...</div>
                <table id="contactsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Username</th>
                            <th>Email</th>
                            <th>Phone</th>
                            <th>Balance</th>
                            <th>Created At</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="contactsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="transactions" class="tab-content">
            <div class="table-container">
                <div class="loading" id="transactionsLoading">Loading transactions...</div>
                <table id="transactionsTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Contact</th>
                            <th>Type</th>
                            <th>Amount</th>
                            <th>Direction</th>
                            <th>Date</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="transactionsBody"></tbody>
                </table>
            </div>
        </div>

        <div id="projections" class="tab-content">
            <div class="table-container">
                <div class="loading" id="projectionsLoading">Loading projections...</div>
                <div id="projectionsContent" style="display: none; padding: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Projection Status</h3>
                    <div id="projectionsInfo"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Detail Modal -->
    <div id="eventModal" class="event-modal" onclick="closeEventModal(event)">
        <div class="event-modal-content" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2>Event Details</h2>
                <button class="event-modal-close" onclick="closeEventModal()">&times;</button>
            </div>
            <div id="eventModalBody"></div>
        </div>
    </div>

    <!-- Event Detail Modal -->
    <div id="eventModal" class="event-modal" onclick="closeEventModal(event)">
        <div class="event-modal-content" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2>Event Details</h2>
                <button class="event-modal-close" onclick="closeEventModal()">&times;</button>
            </div>
            <div id="eventModalBody"></div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8000/api';
        const WS_URL = 'ws://localhost:8000/ws';
        
        // Smart update state
        let lastEventId = null;
        let wsConnection = null;
        let pollingInterval = null;
        let isUpdating = false;
        let currentTotalDebt = null; // Store current total debt for fallback in events
        
        // Chart state
        let debtChart = null;
        let chartPeriod = 'month'; // Default to month
        let currentChartData = []; // Store chart data for click handler
        
        function setChartPeriod(period) {
            chartPeriod = period;
            // Update button states
            document.querySelectorAll('.chart-period-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-period') === period) {
                    btn.classList.add('active');
                }
            });
            loadDebtChart();
        }
        
        // Initialize chart period button state on page load
        function initializeChartPeriod() {
            setChartPeriod('month'); // Set default to month
        }
        
        async function loadDebtChart() {
            try {
                // Calculate date range based on period (rolling periods: last 24h, 7d, 30d, 365d)
                const now = new Date();
                let periodStart = new Date();
                
                switch (chartPeriod) {
                    case 'day':
                        // Last 24 hours
                        periodStart = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                        break;
                    case 'week':
                        // Last 7 days
                        periodStart = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
                        break;
                    case 'month':
                        // Last 30 days
                        periodStart = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
                        break;
                    case 'year':
                        // Last 365 days
                        periodStart = new Date(now.getTime() - (365 * 24 * 60 * 60 * 1000));
                        break;
                }
                
                // Fetch all events since period start
                const params = new URLSearchParams();
                params.append('date_from', periodStart.toISOString());
                params.append('limit', '10000'); // Get all events in range
                
                const response = await fetch(`${API_URL}/admin/events?${params.toString()}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const events = await response.json();
                
                // Sort events by timestamp
                events.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                
                // Build raw event data: time and total_debt
                // Only include transaction events (CREATED, UPDATED, DELETED) - exclude contact events
                const rawEventData = [];
                
                for (const event of events) {
                    // Filter: only transaction events
                    if (event.aggregate_type !== 'transaction') {
                        continue; // Skip contact events
                    }
                    
                    const eventDataObj = event.event_data || {};
                    const totalDebt = eventDataObj.total_debt;
                    
                    if (totalDebt !== null && totalDebt !== undefined) {
                        const debt = Number(totalDebt);
                        if (!isNaN(debt) && isFinite(debt)) {
                            rawEventData.push({
                                timestamp: new Date(event.created_at).getTime(),
                                debt: debt,
                                event: event // Store full event for tooltip
                            });
                        }
                    }
                }
                
                // If no data points, use current total debt
                if (rawEventData.length === 0 && currentTotalDebt !== null) {
                    rawEventData.push({
                        timestamp: new Date().getTime(),
                        debt: currentTotalDebt
                    });
                }
                
                // Determine time scale configuration based on period
                let timeUnit = 'day';
                let timeStepSize = 1;
                let minorUnit = null;
                let minorStepSize = null;
                let displayFormats = {};
                let intervalMs = 0; // Interval size in milliseconds
                
                switch (chartPeriod) {
                    case 'day':
                        timeUnit = 'hour';
                        timeStepSize = 1;
                        minorUnit = 'minute';
                        minorStepSize = 15;
                        intervalMs = 60 * 60 * 1000; // 1 hour intervals
                        displayFormats = {
                            hour: 'HH:mm',
                            minute: 'mm'
                        };
                        break;
                    case 'week':
                        timeUnit = 'day';
                        timeStepSize = 1;
                        intervalMs = 24 * 60 * 60 * 1000; // 1 day intervals
                        displayFormats = {
                            day: 'EEE d'
                        };
                        break;
                    case 'month':
                        timeUnit = 'week';
                        timeStepSize = 1;
                        minorUnit = 'day';
                        minorStepSize = 1;
                        intervalMs = 24 * 60 * 60 * 1000; // 1 day intervals (average per day)
                        displayFormats = {
                            week: 'MMM d',
                            day: 'd'
                        };
                        break;
                    case 'year':
                        timeUnit = 'month';
                        timeStepSize = 1;
                        minorUnit = 'week';
                        minorStepSize = 1;
                        intervalMs = 7 * 24 * 60 * 60 * 1000; // 1 week intervals (average per week)
                        displayFormats = {
                            month: 'MMM yyyy',
                            week: 'w'
                        };
                        break;
                }
                
                // Set date range - always start from period start, even if no data
                const maxDate = now.getTime();
                const minDate = periodStart.getTime();
                
                // Calculate average debt for each time interval
                const chartData = [];
                const numIntervals = Math.ceil((maxDate - minDate) / intervalMs);
                
                for (let i = 0; i <= numIntervals; i++) {
                    const intervalStart = minDate + (i * intervalMs);
                    const intervalEnd = Math.min(intervalStart + intervalMs, maxDate);
                    const intervalCenter = intervalStart + (intervalMs / 2);
                    
                    // Find all events in this interval
                    const eventsInInterval = rawEventData.filter(evt => 
                        evt.timestamp >= intervalStart && evt.timestamp < intervalEnd
                    );
                    
                    let avgDebt = null;
                    let intervalEvents = []; // Store all events in this interval for tooltip
                    let hasTransactions = false; // Track if this interval has actual transactions
                    
                    if (eventsInInterval.length > 0) {
                        // Calculate average debt for this interval
                        const sum = eventsInInterval.reduce((acc, evt) => acc + evt.debt, 0);
                        avgDebt = sum / eventsInInterval.length;
                        // Store all events in this interval for tooltip
                        intervalEvents = eventsInInterval.map(evt => evt.event).filter(e => e !== null);
                        hasTransactions = true; // This interval has transactions
                    } else {
                        // No events in this interval - find the closest event before this interval
                        const beforeEvents = rawEventData.filter(evt => evt.timestamp < intervalStart);
                        if (beforeEvents.length > 0) {
                            // Use the debt value from the most recent event before this interval
                            const closestBefore = beforeEvents[beforeEvents.length - 1];
                            avgDebt = closestBefore.debt;
                            // Don't store events - this interval has no transactions
                            intervalEvents = [];
                            hasTransactions = false;
                        } else if (rawEventData.length > 0) {
                            // Use the first event's debt if no events before
                            avgDebt = rawEventData[0].debt;
                            intervalEvents = [];
                            hasTransactions = false;
                        } else {
                            // No data at all
                            avgDebt = currentTotalDebt || 0;
                            intervalEvents = [];
                            hasTransactions = false;
                        }
                    }
                    
                    chartData.push({
                        x: intervalCenter,
                        y: avgDebt,
                        events: intervalEvents, // Store all events in interval for tooltip
                        hasTransactions: hasTransactions, // Flag to show/hide point
                        intervalStart: intervalStart, // Store for click handler
                        intervalEnd: intervalEnd // Store for click handler
                    });
                }
                
                // Store chart data globally for click handler
                currentChartData = chartData;
                
                // Create or update chart
                const ctx = document.getElementById('debtChart');
                const isDark = document.body.classList.contains('dark-mode');
                
                const chartConfig = {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Total Debt (IQD)',
                            data: chartData,
                            borderColor: '#6750A4',
                            backgroundColor: 'rgba(103, 80, 164, 0.1)',
                            borderWidth: 2,
                            fill: false, // No fill - just line connecting actual events
                            tension: 0.4, // Smooth curves passing through actual event points
                            pointRadius: function(context) {
                                // Hide points where no transactions occurred
                                return context.raw?.hasTransactions ? 4 : 0;
                            },
                            pointHoverRadius: function(context) {
                                // Only allow hover on points with transactions
                                return context.raw?.hasTransactions ? 6 : 0;
                            },
                            pointBackgroundColor: '#6750A4',
                            pointBorderColor: isDark ? '#1C1B1F' : '#FFFBFE',
                            pointBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: isDark ? '#E6E1E5' : '#1C1B1F',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: isDark ? '#49454F' : '#FFFBFE',
                                titleColor: isDark ? '#E6E1E5' : '#1C1B1F',
                                bodyColor: isDark ? '#E6E1E5' : '#1C1B1F',
                                borderColor: '#6750A4',
                                borderWidth: 1,
                                padding: 8,
                                titleFont: { size: 12, weight: '600' },
                                bodyFont: { size: 11 },
                                titleSpacing: 4,
                                bodySpacing: 3,
                                displayColors: false,
                                callbacks: {
                                    title: function(context) {
                                        const point = context[0];
                                        const hasTransactions = point.raw?.hasTransactions || false;
                                        
                                        // Only show tooltip if there are transactions in this interval
                                        if (!hasTransactions) {
                                            return null; // Hide tooltip for intervals with no transactions
                                        }
                                        
                                        // Calculate interval size based on chart period
                                        let intervalSize = 0;
                                        switch (chartPeriod) {
                                            case 'day': intervalSize = 60 * 60 * 1000; break; // 1 hour
                                            case 'week': intervalSize = 24 * 60 * 60 * 1000; break; // 1 day
                                            case 'month': intervalSize = 24 * 60 * 60 * 1000; break; // 1 day
                                            case 'year': intervalSize = 7 * 24 * 60 * 60 * 1000; break; // 1 week
                                        }
                                        
                                        // Show interval time range
                                        const intervalStart = new Date(point.parsed.x - (intervalSize / 2));
                                        const intervalEnd = new Date(point.parsed.x + (intervalSize / 2));
                                        
                                        let title = intervalStart.toLocaleString('en-US', {
                                            month: 'short',
                                            day: 'numeric',
                                            hour: 'numeric',
                                            minute: '2-digit'
                                        });
                                        
                                        // Determine format based on interval size
                                        if (intervalSize <= 60 * 60 * 1000) {
                                            // Hour or smaller intervals - show time only for end
                                            title += ' - ' + intervalEnd.toLocaleTimeString('en-US', {
                                                hour: 'numeric',
                                                minute: '2-digit'
                                            });
                                        } else {
                                            // Day or larger intervals - show full date/time
                                            title += ' - ' + intervalEnd.toLocaleString('en-US', {
                                                month: 'short',
                                                day: 'numeric',
                                                hour: 'numeric',
                                                minute: '2-digit'
                                            });
                                        }
                                        
                                        return title;
                                    },
                                    label: function(context) {
                                        const point = context;
                                        const events = point.raw?.events || [];
                                        const hasTransactions = point.raw?.hasTransactions || false;
                                        
                                        // Only show tooltip if there are transactions in this interval
                                        if (!hasTransactions || events.length === 0) {
                                            return null; // Hide tooltip for intervals with no transactions
                                        }
                                        
                                        const debt = Math.round(context.parsed.y);
                                        const lines = [`Avg: ${debt.toLocaleString('en-US')} IQD ‚Ä¢ ${events.length} tx`];
                                        
                                        if (events.length > 0) {
                                            // Show up to 4 transactions in compact format
                                            const maxShow = 4;
                                            const eventsToShow = events.slice(0, maxShow);
                                            
                                            eventsToShow.forEach((event) => {
                                                const eventData = event.event_data || {};
                                                const date = new Date(event.created_at);
                                                const timeStr = date.toLocaleTimeString('en-US', {
                                                    hour: 'numeric',
                                                    minute: '2-digit'
                                                });
                                                
                                                let txLine = `${timeStr} `;
                                                
                                                if (eventData.amount !== null && eventData.amount !== undefined) {
                                                    const amount = Number(eventData.amount);
                                                    // Standardization: Received (owed) = -, Gave (lent) = +
                                                    const sign = eventData.direction === 'lent' ? '+' : '-';
                                                    const currency = eventData.currency || 'IQD';
                                                    txLine += `${sign}${Math.round(amount).toLocaleString('en-US')} ${currency}`;
                                                } else {
                                                    txLine += event.event_type;
                                                }
                                                
                                                if (contactNameCache[eventData.contact_id]) {
                                                    txLine += ` ‚Ä¢ ${contactNameCache[eventData.contact_id]}`;
                                                }
                                                
                                                lines.push(txLine);
                                            });
                                            
                                            if (events.length > maxShow) {
                                                lines.push(`+${events.length - maxShow} more`);
                                            }
                                        }
                                        
                                        return lines;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: timeUnit,
                                    stepSize: timeStepSize,
                                    displayFormats: displayFormats,
                                    tooltipFormat: 'PPpp'
                                },
                                min: minDate,
                                max: maxDate,
                                ticks: {
                                    color: isDark ? '#938F99' : '#79747E',
                                    maxRotation: 45,
                                    minRotation: 45,
                                    source: 'auto',
                                    autoSkip: true
                                },
                                grid: {
                                    color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                                    drawOnChartArea: true
                                },
                                ...(minorUnit && minorStepSize ? {
                                    minor: {
                                        unit: minorUnit,
                                        stepSize: minorStepSize,
                                        display: true
                                    },
                                    grid: {
                                        ...(isDark ? {
                                            color: 'rgba(255, 255, 255, 0.05)'
                                        } : {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }),
                                        drawOnChartArea: true,
                                        drawTicks: false
                                    }
                                } : {})
                            },
                            y: {
                                reverse: true, // Zero at bottom
                                ticks: {
                                    color: isDark ? '#938F99' : '#79747E',
                                    callback: function(value) {
                                        return Math.round(value).toLocaleString('en-US') + ' IQD';
                                    }
                                },
                                grid: {
                                    color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        onClick: function(event, elements) {
                            if (elements.length > 0) {
                                const element = elements[0];
                                const point = currentChartData[element.index];
                                
                                // Only filter if this point has transactions
                                if (point && point.hasTransactions) {
                                    // Format dates for input fields (YYYY-MM-DD)
                                    const formatDate = (timestamp) => {
                                        const date = new Date(timestamp);
                                        const year = date.getFullYear();
                                        const month = String(date.getMonth() + 1).padStart(2, '0');
                                        const day = String(date.getDate()).padStart(2, '0');
                                        return `${year}-${month}-${day}`;
                                    };
                                    
                                    // Set filter dates using stored interval boundaries
                                    document.getElementById('dateFromFilter').value = formatDate(point.intervalStart);
                                    document.getElementById('dateToFilter').value = formatDate(point.intervalEnd);
                                    
                                    // Switch to Events tab if not already there
                                    switchTab('events');
                                    
                                    // Apply filters to show events in this time period
                                    applyFilters();
                                }
                            }
                        }
                    }
                };
                
                if (debtChart) {
                    // Destroy and recreate chart to ensure all colors update properly
                    debtChart.destroy();
                    debtChart = null;
                }
                
                // Create new chart with current dark mode state
                debtChart = new Chart(ctx, chartConfig);
            } catch (error) {
                console.error('Error loading debt chart:', error);
            }
        }

        async function loadData() {
            // Load stats first to populate currentTotalDebt
            await loadStats();
            // Then load events (which will use currentTotalDebt as fallback)
            await Promise.all([
                loadEvents(),
                loadContacts(),
                loadTransactions(),
                loadProjections(),
                loadDebtChart()
            ]);
        }

        async function loadStats() {
            try {
                const [contacts, transactions] = await Promise.all([
                    fetch(`${API_URL}/admin/contacts`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    }),
                    fetch(`${API_URL}/admin/transactions`).then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.json();
                    })
                ]);

                const totalDebt = transactions.reduce((sum, t) => {
                    if (t.type === 'money') {
                        return sum + (t.direction === 'owed' ? -t.amount : t.amount);
                    }
                    return sum;
                }, 0);

                const formatAmount = (amt) => {
                    return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                };

                document.getElementById('totalContacts').textContent = contacts.length;
                document.getElementById('totalTransactions').textContent = transactions.length;
                const totalDebtText = `${formatAmount(totalDebt)} IQD`;
                document.getElementById('totalDebt').textContent = totalDebtText;
                currentTotalDebt = totalDebt; // Store for fallback in events
                document.getElementById('pendingReminders').textContent = '0'; // TODO
            } catch (error) {
                console.error('Error loading stats:', error);
                document.getElementById('totalContacts').textContent = 'Error';
                document.getElementById('totalTransactions').textContent = 'Error';
            }
        }

        // Events log state
        let currentPage = 0;
        let pageSize = 100;
        let searchTimeout = null;

        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentPage = 0; // Reset to first page on new search
                applyFilters();
            }, 500);
        }

        function clearFilters() {
            document.getElementById('eventSearch').value = '';
            document.getElementById('eventTypeFilter').value = '';
            document.getElementById('aggregateTypeFilter').value = '';
            document.getElementById('dateFromFilter').value = '';
            document.getElementById('dateToFilter').value = '';
            currentPage = 0;
            applyFilters();
        }

        function previousPage() {
            if (currentPage > 0) {
                currentPage--;
                applyFilters();
            }
        }

        function nextPage() {
            currentPage++;
            applyFilters();
        }

        function applyFilters() {
            pageSize = parseInt(document.getElementById('pageSize').value) || 100;
            loadEvents();
        }

        async function loadEvents(silent = false) {
            if (isUpdating && !silent) return; // Prevent concurrent updates unless silent
            isUpdating = true;
            
            const loading = document.getElementById('eventsLoading');
            const table = document.getElementById('eventsTable');
            const body = document.getElementById('eventsBody');
            const countSpan = document.getElementById('eventsCount');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            // Build query parameters
            const params = new URLSearchParams();
            params.append('limit', pageSize.toString());
            params.append('offset', (currentPage * pageSize).toString());
            
            const search = document.getElementById('eventSearch').value.trim();
            if (search) {
                params.append('search', search);
            }
            
            const eventType = document.getElementById('eventTypeFilter').value;
            if (eventType) {
                params.append('event_type', eventType);
            }
            
            const aggregateType = document.getElementById('aggregateTypeFilter').value;
            if (aggregateType) {
                params.append('aggregate_type', aggregateType);
            }
            
            const dateFrom = document.getElementById('dateFromFilter').value;
            if (dateFrom) {
                params.append('date_from', dateFrom + 'T00:00:00');
            }
            
            const dateTo = document.getElementById('dateToFilter').value;
            if (dateTo) {
                params.append('date_to', dateTo + 'T23:59:59');
            }

            try {
                if (!silent) {
                    loading.style.display = 'block';
                    table.style.display = 'none';
                }
                
                const response = await fetch(`${API_URL}/admin/events?${params.toString()}`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const events = await response.json();

                // Pre-load contact names for all events
                const contactIds = new Set();
                events.forEach(event => {
                    if (event.aggregate_type === 'contact') {
                        const name = event.event_data?.name;
                        if (name) contactNameCache[event.aggregate_id] = name;
                    } else if (event.aggregate_type === 'transaction') {
                        const contactId = event.event_data?.contact_id;
                        if (contactId) contactIds.add(contactId);
                    }
                });
                
                // Fetch missing contact names
                if (contactIds.size > 0) {
                    try {
                        const contactsResponse = await fetch(`${API_URL}/admin/contacts`);
                        if (contactsResponse.ok) {
                            const contacts = await contactsResponse.json();
                            contacts.forEach(contact => {
                                if (contactIds.has(contact.id)) {
                                    contactNameCache[contact.id] = contact.name;
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error pre-loading contacts:', e);
                    }
                }

                if (!silent) {
                loading.style.display = 'none';
                }
                table.style.display = 'table';
                
                // Update count
                countSpan.textContent = `Showing ${events.length} event(s)`;
                
                // Update pagination
                pageInfo.textContent = `Page ${currentPage + 1}`;
                prevBtn.disabled = currentPage === 0;
                prevBtn.style.opacity = currentPage === 0 ? '0.5' : '1';
                prevBtn.style.cursor = currentPage === 0 ? 'not-allowed' : 'pointer';
                nextBtn.disabled = events.length < pageSize;
                nextBtn.style.opacity = events.length < pageSize ? '0.5' : '1';
                nextBtn.style.cursor = events.length < pageSize ? 'not-allowed' : 'pointer';
                
                // Smooth DOM update - only replace if content changed
                const newContent = renderEvents(events);
                const currentContent = body.innerHTML;
                
                if (newContent !== currentContent) {
                    // Add fade effect for smooth update
                    if (silent) {
                        body.style.transition = 'opacity 0.2s';
                        body.style.opacity = '0.7';
                        setTimeout(() => {
                            body.innerHTML = newContent;
                            body.style.opacity = '1';
                        }, 100);
                    } else {
                        body.innerHTML = newContent;
                    }
                }
            } catch (error) {
                if (!silent) {
                loading.innerHTML = `<div class="error">Error loading events: ${error.message}</div>`;
                }
                console.error('Error:', error);
            } finally {
                isUpdating = false;
            }
        }
        
        // Extract event rendering to separate function for reuse
        // Cache for contact names (to avoid repeated lookups)
        let contactNameCache = {};
        
        async function getContactName(contactId) {
            if (!contactId) return null;
            if (contactNameCache[contactId]) return contactNameCache[contactId];
            
            try {
                const response = await fetch(`${API_URL}/admin/contacts`);
                if (response.ok) {
                    const contacts = await response.json();
                    const contact = contacts.find(c => c.id === contactId);
                    if (contact) {
                        contactNameCache[contactId] = contact.name;
                        return contact.name;
                    }
                }
            } catch (e) {
                console.error('Error fetching contact name:', e);
            }
            return null;
        }
        
        // Event modal functions
        function showEventModal(event) {
            const modal = document.getElementById('eventModal');
            const body = document.getElementById('eventModalBody');
            
            const eventData = event.event_data || {};
            const contactId = eventData.contact_id || null;
            const contactName = contactId ? (contactNameCache[contactId] || 'Unknown') : null;
            
            let html = '';
            
            // Basic Info
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Event ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(event.event_id) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Event Type</div><div class="event-modal-field-value">' + escapeHtml(event.event_type) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Aggregate Type</div><div class="event-modal-field-value">' + escapeHtml(event.aggregate_type) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Aggregate ID</div><div class="event-modal-field-value" style="font-family: monospace; font-size: 0.9rem;">' + escapeHtml(event.aggregate_id) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Created At</div><div class="event-modal-field-value">' + formatDateTime(event.created_at) + '</div></div>';
            html += '<div class="event-modal-field"><div class="event-modal-field-label">User</div><div class="event-modal-field-value">' + escapeHtml(eventData.username || event.user_email || event.user_id) + '</div></div>';
            
            // Contact Info
            if (event.aggregate_type === 'contact') {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact Name</div><div class="event-modal-field-value">' + escapeHtml(eventData.name || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Username</div><div class="event-modal-field-value">' + escapeHtml(eventData.username || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Phone</div><div class="event-modal-field-value">' + escapeHtml(eventData.phone || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Email</div><div class="event-modal-field-value">' + escapeHtml(eventData.email || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Notes</div><div class="event-modal-field-value">' + escapeHtml(eventData.notes || 'N/A') + '</div></div>';
            } else if (event.aggregate_type === 'transaction') {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Contact</div><div class="event-modal-field-value">' + escapeHtml(contactName || 'Unknown') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Type</div><div class="event-modal-field-value">' + escapeHtml(eventData.type || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Direction</div><div class="event-modal-field-value">' + escapeHtml(eventData.direction || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Amount</div><div class="event-modal-field-value">' + (eventData.amount ? eventData.amount.toLocaleString('en-US') + ' ' + (eventData.currency || 'IQD') : 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Transaction Date</div><div class="event-modal-field-value">' + escapeHtml(eventData.transaction_date || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Due Date</div><div class="event-modal-field-value">' + escapeHtml(eventData.due_date || 'N/A') + '</div></div>';
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Description</div><div class="event-modal-field-value">' + escapeHtml(eventData.description || 'N/A') + '</div></div>';
            }
            
            // Total Debt
            if (eventData.total_debt !== null && eventData.total_debt !== undefined) {
                const debt = Number(eventData.total_debt);
                if (!isNaN(debt) && isFinite(debt)) {
                    html += '<div class="event-modal-field"><div class="event-modal-field-label">Total Debt (after this event)</div><div class="event-modal-field-value" style="font-weight: 600; color: #6750A4; font-size: 1.1rem;">' + Math.round(debt).toLocaleString('en-US') + ' IQD</div></div>';
                }
            }
            
            // Comment
            if (eventData.comment) {
                html += '<div class="event-modal-field"><div class="event-modal-field-label">Comment</div><div class="event-modal-field-value">' + escapeHtml(eventData.comment) + '</div></div>';
            }
            
            // Full Event Data
            html += '<div class="event-modal-field"><div class="event-modal-field-label">Full Event Data (JSON)</div><pre class="details-pre" style="padding: 1rem; border-radius: 4px; overflow: auto; max-height: 300px; font-size: 0.85rem; margin-top: 0.5rem;">' + escapeHtml(JSON.stringify(event, null, 2)) + '</pre></div>';
            
            body.innerHTML = html;
            modal.classList.add('active');
        }
        
        function closeEventModal(e) {
            if (e && e.target.id !== 'eventModal' && !e.target.classList.contains('event-modal-close')) {
                return;
            }
            const modal = document.getElementById('eventModal');
            modal.classList.remove('active');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function renderEvents(events) {
            return events.map(event => {
                    // event.event_data is already a parsed JSON object from the API
                    const eventData = event.event_data || {};
                    const comment = eventData.comment || eventData.Comment || null;
                    const name = eventData.name || eventData.Name || null;
                    const amount = eventData.amount || null;
                    const direction = eventData.direction || null;
                    const type = eventData.type || null;
                    const description = eventData.description || null;
                    const contactId = eventData.contact_id || null;
                    const username = eventData.username || eventData.Username || null;
                    // Get total_debt from event_data (this is the value saved in the database at event execution time)
                    let totalDebt = null;
                    
                    // eventData is already a parsed JSON object from the database
                    if (eventData && typeof eventData === 'object') {
                        // Check for total_debt (snake_case - as stored in database)
                        if (eventData.hasOwnProperty('total_debt')) {
                            totalDebt = eventData.total_debt;
                        }
                        // Also check for totalDebt (camelCase - just in case)
                        else if (eventData.hasOwnProperty('totalDebt')) {
                            totalDebt = eventData.totalDebt;
                        }
                    }
                    
                    // Convert to number if needed (handle string, number, or other types)
                    if (totalDebt !== null && totalDebt !== undefined) {
                        if (typeof totalDebt === 'number') {
                            // Already a number, check if valid
                            if (isNaN(totalDebt) || !isFinite(totalDebt)) {
                                totalDebt = null;
                            }
                        } else if (typeof totalDebt === 'string') {
                            const parsed = parseFloat(totalDebt);
                            if (!isNaN(parsed) && isFinite(parsed)) {
                                totalDebt = parsed;
                            } else {
                                totalDebt = null;
                            }
                        } else {
                            // Try to convert other types to number
                            const num = Number(totalDebt);
                            if (!isNaN(num) && isFinite(num)) {
                                totalDebt = num;
                            } else {
                                totalDebt = null;
                            }
                        }
                    }
                    
                    // Determine contact name - show name instead of ID
                    let contactName = null;
                    if (event.aggregate_type === 'contact') {
                        contactName = name || 'Unknown';
                    } else if (contactId) {
                        contactName = contactNameCache[contactId] || 'Unknown Contact';
                    }
                    
                    // User display - show username only (no ID)
                    const userDisplay = username || event.user_email || 'N/A';
                    
                    // Format total debt - show the value saved in database at event execution time
                    let totalDebtDisplay = 'N/A';
                    if (totalDebt !== null && totalDebt !== undefined) {
                        const num = Number(totalDebt);
                        if (!isNaN(num) && isFinite(num)) {
                            totalDebtDisplay = `${Math.round(num).toLocaleString('en-US')} IQD`;
                        }
                    }
                    
                    // Get event type badge color
                    let badgeClass = 'badge';
                    const eventTypeUpper = event.event_type.toUpperCase();
                    if (eventTypeUpper.includes('CREATED') || eventTypeUpper.includes('CREATE')) {
                        badgeClass += ' success';
                    } else if (eventTypeUpper.includes('UPDATED') || eventTypeUpper.includes('UPDATE')) {
                        badgeClass += ' warning';
                    } else if (eventTypeUpper.includes('DELETED') || eventTypeUpper.includes('DELETE')) {
                        badgeClass += ' error';
                    }
                    
                    // Format event type for display
                    const displayEventType = event.event_type
                        .replace(/_/g, ' ')
                        .split(' ')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');
                    
                    // Format aggregate type
                    const aggregateDisplay = event.aggregate_type.charAt(0).toUpperCase() + event.aggregate_type.slice(1);
                    
                    // Format amount display with +/- and colors
                    let amountDisplay = '-';
                    if (event.aggregate_type === 'transaction' && amount !== null) {
                        const amountNum = Number(amount);
                        if (!isNaN(amountNum) && isFinite(amountNum)) {
                            const currency = eventData.currency || 'IQD';
                            // Standardization: Received (owed) = red (negative) = -, Gave (lent) = green (positive) = +
                            const isReceived = direction === 'owed'; // owed = Received
                            const isGave = direction === 'lent'; // lent = Gave
                            const sign = isGave ? '+' : '-'; // Gave = +, Received = -
                            const amountColor = isGave ? 'color: #16A34A;' : 'color: #BA1A1A;'; // Gave = green, Received = red
                            amountDisplay = `<span style="${amountColor} font-weight: 600;">${sign} ${Math.round(amountNum).toLocaleString('en-US')} ${currency}</span>`;
                        }
                    }
                    
                    // Store event data as JSON for modal (properly escaped)
                    const eventJson = JSON.stringify(event).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    
                    return `
                        <tr class="event-row" onclick='showEventModal(${JSON.stringify(event)})' data-event-id="${event.event_id}">
                            <td style="white-space: nowrap; font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${formatDateTime(event.created_at)}
                            </td>
                            <td style="padding: 0.4rem 0.5rem;">
                                <span class="${badgeClass}" style="font-size: 0.7rem;">${displayEventType}</span>
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${contactName || aggregateDisplay}
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${amountDisplay !== '-' ? amountDisplay : '-'}
                            </td>
                            <td style="font-size: 0.75rem; font-weight: 600; color: #6750A4; white-space: nowrap; padding: 0.4rem 0.5rem;">
                                ${totalDebtDisplay}
                            </td>
                            <td style="font-size: 0.75rem; padding: 0.4rem 0.5rem;">
                                ${userDisplay}
                            </td>
                            <td style="max-width: 150px; font-size: 0.7rem; padding: 0.4rem 0.5rem;">
                                ${comment ? `<div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${comment.replace(/"/g, '&quot;')}">${comment.substring(0, 30)}${comment.length > 30 ? '...' : ''}</div>` : '<em style="color: #938F99;">-</em>'}
                            </td>
                            <td style="font-size: 0.7rem; padding: 0.4rem 0.5rem;">
                                <span style="color: #6750A4; cursor: pointer;">View</span>
                            </td>
                        </tr>
                    `;
            }).join('');
        }
        
        // Smart update system - only updates when there are changes
        function startSmartUpdates() {
            // First, get the latest event ID
            fetch(`${API_URL}/admin/events/latest`)
                .then(r => r.json())
                .then(data => {
                    lastEventId = data.latest_event_id;
                })
                .catch(err => console.error('Error getting latest event ID:', err));
            
            // Try WebSocket first (real-time)
            try {
                wsConnection = new WebSocket(WS_URL);
                
                wsConnection.onopen = () => {
                    console.log('‚úÖ WebSocket connected for real-time updates');
                };
                
                wsConnection.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        // When we receive a WebSocket event, check if it's an event-related change
                        if (message.type && (message.type.includes('contact') || message.type.includes('transaction'))) {
                            // New event created, update the list
                            checkForUpdates();
                        }
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                    }
                };
                
                wsConnection.onerror = (error) => {
                    console.log('WebSocket error, falling back to polling:', error);
                    // Fallback to polling if WebSocket fails
                    startPolling();
                };
                
                wsConnection.onclose = () => {
                    console.log('WebSocket closed, falling back to polling');
                    startPolling();
                };
            } catch (e) {
                console.log('WebSocket not available, using polling:', e);
                startPolling();
            }
        }
        
        // Smart polling - only updates when there are changes
        function startPolling() {
            if (pollingInterval) clearInterval(pollingInterval);
            
            pollingInterval = setInterval(async () => {
                // Only check if events tab is active and no filters are applied
                const hasFilters = document.getElementById('eventSearch')?.value.trim() ||
                                  document.getElementById('eventTypeFilter')?.value ||
                                  document.getElementById('aggregateTypeFilter')?.value ||
                                  document.getElementById('dateFromFilter')?.value ||
                                  document.getElementById('dateToFilter')?.value;
                
                if (hasFilters || !document.getElementById('events')?.classList.contains('active')) {
                    return; // Don't auto-update if filters are active or tab is not visible
                }
                
                // Check for changes
                await checkForUpdates();
            }, 3000); // Check every 3 seconds
        }
        
        // Check for updates (used by WebSocket and polling)
        async function checkForUpdates() {
            try {
                const response = await fetch(`${API_URL}/admin/events/latest`);
                const data = await response.json();
                
                if (data.latest_event_id !== null && data.latest_event_id !== lastEventId) {
                    // There are new events!
                    console.log('üîÑ New events detected, updating...');
                    lastEventId = data.latest_event_id;
                    // Smoothly update without page reload
                    await loadEvents(true); // true = silent update
                    // Update chart only when there are new events
                    await loadDebtChart();
                }
            } catch (err) {
                console.error('Error checking for updates:', err);
            }
        }

        async function loadContacts() {
            const loading = document.getElementById('contactsLoading');
            const table = document.getElementById('contactsTable');
            const body = document.getElementById('contactsBody');

            try {
                const response = await fetch(`${API_URL}/admin/contacts`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const contacts = await response.json();

                loading.style.display = 'none';
                table.style.display = 'table';
                body.innerHTML = contacts.map(contact => {
                    // Balance is stored as whole units (IQD), format with commas
                    const formatAmount = (amt) => {
                        return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };
                    const balance = contact.balance ? `${formatAmount(contact.balance)} IQD` : '0 IQD';
                    return `
                    <tr>
                        <td>${contact.id.substring(0, 8)}...</td>
                        <td>${contact.name}</td>
                        <td>${contact.username ? '@' + contact.username : '-'}</td>
                        <td>${contact.email || '-'}</td>
                        <td>${contact.phone || '-'}</td>
                        <td>${balance}</td>
                        <td>${formatDateTime(contact.created_at)}</td>
                        <td><span class="badge ${contact.is_deleted ? 'error' : 'success'}">${contact.is_deleted ? 'Deleted' : 'Active'}</span></td>
                    </tr>
                `;
                }).join('');
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading contacts: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        async function loadTransactions() {
            const loading = document.getElementById('transactionsLoading');
            const table = document.getElementById('transactionsTable');
            const body = document.getElementById('transactionsBody');

            try {
                const response = await fetch(`${API_URL}/admin/transactions`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const transactions = await response.json();
                const contactsResponse = await fetch(`${API_URL}/admin/contacts`);
                let contacts = [];
                if (contactsResponse.ok) {
                    contacts = await contactsResponse.json();
                }
                const contactMap = new Map(contacts.map(c => [c.id, c.name]));

                loading.style.display = 'none';
                table.style.display = 'table';
                body.innerHTML = transactions.map(t => {
                    // Amount is stored as whole units (IQD), format with commas
                    const formatAmount = (amt) => {
                        return amt.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    };
                    const amount = t.type === 'money' ? `${formatAmount(t.amount)} IQD` : `${t.amount} item(s)`;
                    return `
                        <tr>
                            <td>${t.id.substring(0, 8)}...</td>
                            <td>${contactMap.get(t.contact_id) || 'Unknown'}</td>
                            <td>${t.type}</td>
                            <td>${amount}</td>
                            <td><span class="badge ${t.direction === 'owed' ? 'error' : 'success'}">${t.direction}</span></td>
                            <td>${new Date(t.transaction_date).toLocaleDateString()}</td>
                            <td><span class="badge success">Active</span></td>
                        </tr>
                    `;
                }).join('');
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading transactions: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        async function loadProjections() {
            const loading = document.getElementById('projectionsLoading');
            const content = document.getElementById('projectionsContent');
            const info = document.getElementById('projectionsInfo');

            try {
                const response = await fetch(`${API_URL}/admin/projections/status`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }
                const status = await response.json();

                loading.style.display = 'none';
                content.style.display = 'block';
                info.innerHTML = `
                    <div class="projection-info" style="background: #E7E0EC; padding: 1rem; border-radius: 4px; margin-bottom: 1rem; color: #1C1B1F;">
                        <strong>Last Event ID:</strong> ${status.last_event_id || 'N/A'}<br>
                        <strong>Projections Updated:</strong> ${status.projections_updated || 'N/A'}<br>
                        <strong>Last Update:</strong> ${status.last_update ? new Date(status.last_update).toLocaleString() : 'N/A'}
                    </div>
                    <pre class="details-pre" style="background: #E7E0EC; padding: 1rem; border-radius: 4px; overflow: auto; color: #1C1B1F;">${JSON.stringify(status, null, 2)}</pre>
                `;
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading projections: ${error.message}</div>`;
                console.error('Error:', error);
            }
        }

        function formatDateTime(dateStr) {
            if (!dateStr) return 'N/A';
            try {
                // Handle both ISO strings and NaiveDateTime format
                const date = new Date(dateStr);
                return date.toLocaleString();
            } catch (e) {
                return dateStr;
            }
        }


        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Find and activate the clicked tab button
            document.querySelectorAll('.tab').forEach(tab => {
                if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(tabName)) {
                    tab.classList.add('active');
                }
            });
            document.getElementById(tabName).classList.add('active');
        }

        // Dark mode toggle - default to dark mode
        const darkModeToggle = document.getElementById('darkModeToggle');
        const storedMode = localStorage.getItem('darkMode');
        // Default to dark mode if not set
        const isDarkMode = storedMode === null ? true : storedMode === 'true';
        
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            darkModeToggle.textContent = '‚òÄÔ∏è Light Mode';
            // Save default if not set
            if (storedMode === null) {
                localStorage.setItem('darkMode', 'true');
            }
        }
        
        darkModeToggle.addEventListener('click', () => {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark);
            darkModeToggle.textContent = isDark ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
            // Recreate chart with new dark mode state
            if (debtChart) {
                loadDebtChart();
            }
        });

        // Initialize chart period button state
        initializeChartPeriod();
        
        // Load data on page load
        loadData();
        
        // Start smart updates (WebSocket + polling fallback)
        startSmartUpdates();
        
        // Auto-refresh other data every 10 seconds (chart excluded - only updates on data changes)
        setInterval(() => {
            loadStats();
            loadContacts();
            loadTransactions();
            // Chart is only updated when events change (via smart updates)
        }, 10000);
    </script>
</body>
</html>
