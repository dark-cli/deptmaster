// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `append_event`, `ensure_wallet`, `is_within_undo_window`, `last_event_for_aggregate`, `rebuild_and_save`

Future<Contact> createContact(
        {required String name,
        String? username,
        String? phone,
        String? email,
        String? notes,
        List<String>? groupIds}) =>
    RustLib.instance.api.crateCrudCreateContact(
        name: name,
        username: username,
        phone: phone,
        email: email,
        notes: notes,
        groupIds: groupIds);

Future<String> getContacts() => RustLib.instance.api.crateCrudGetContacts();

Future<String> getTransactions() =>
    RustLib.instance.api.crateCrudGetTransactions();

Future<String?> getContact({required String id}) =>
    RustLib.instance.api.crateCrudGetContact(id: id);

Future<String?> getTransaction({required String id}) =>
    RustLib.instance.api.crateCrudGetTransaction(id: id);

Future<Transaction> createTransaction(
        {required String contactId,
        required String type,
        required String direction,
        required PlatformInt64 amount,
        required String currency,
        String? description,
        required String transactionDate,
        String? dueDate}) =>
    RustLib.instance.api.crateCrudCreateTransaction(
        contactId: contactId,
        type: type,
        direction: direction,
        amount: amount,
        currency: currency,
        description: description,
        transactionDate: transactionDate,
        dueDate: dueDate);

Future<void> updateContact(
        {required String id,
        required String name,
        String? username,
        String? phone,
        String? email,
        String? notes,
        List<String>? groupIds}) =>
    RustLib.instance.api.crateCrudUpdateContact(
        id: id,
        name: name,
        username: username,
        phone: phone,
        email: email,
        notes: notes,
        groupIds: groupIds);

Future<void> deleteContact({required String contactId}) =>
    RustLib.instance.api.crateCrudDeleteContact(contactId: contactId);

Future<void> updateTransaction(
        {required String id,
        required String contactId,
        required String type,
        required String direction,
        required PlatformInt64 amount,
        required String currency,
        String? description,
        required String transactionDate,
        String? dueDate}) =>
    RustLib.instance.api.crateCrudUpdateTransaction(
        id: id,
        contactId: contactId,
        type: type,
        direction: direction,
        amount: amount,
        currency: currency,
        description: description,
        transactionDate: transactionDate,
        dueDate: dueDate);

/// Delete transaction: if last event is within 5s, append UNDO; otherwise append DELETED.
Future<void> deleteTransaction({required String transactionId}) =>
    RustLib.instance.api
        .crateCrudDeleteTransaction(transactionId: transactionId);

/// Undo last action for a contact (append UNDO event). Fails if last event is older than 5s.
Future<void> undoContactAction({required String contactId}) =>
    RustLib.instance.api.crateCrudUndoContactAction(contactId: contactId);

/// Undo last action for a transaction (append UNDO event). Fails if last event is older than 5s.
Future<void> undoTransactionAction({required String transactionId}) =>
    RustLib.instance.api
        .crateCrudUndoTransactionAction(transactionId: transactionId);

Future<void> bulkDeleteContacts({required List<String> contactIds}) =>
    RustLib.instance.api.crateCrudBulkDeleteContacts(contactIds: contactIds);

Future<void> bulkDeleteTransactions({required List<String> transactionIds}) =>
    RustLib.instance.api
        .crateCrudBulkDeleteTransactions(transactionIds: transactionIds);

Future<void> logout() => RustLib.instance.api.crateCrudLogout();
