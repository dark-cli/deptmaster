// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `hash`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>
abstract class Event implements RustOpaqueInterface {
  String get aggregateId;

  String get aggregateType;

  Value get eventData;

  String get eventType;

  String get id;

  bool get synced;

  String get timestamp;

  int get version;

  set aggregateId(String aggregateId);

  set aggregateType(String aggregateType);

  set eventData(Value eventData);

  set eventType(String eventType);

  set id(String id);

  set synced(bool synced);

  set timestamp(String timestamp);

  set version(int version);
}

/// Contact (wire format: strings for IDs and dates for JSON/FFI).
class Contact {
  final String id;
  final String name;
  final String? username;
  final String? phone;
  final String? email;
  final String? notes;
  final String createdAt;
  final String updatedAt;
  final bool isSynced;
  final PlatformInt64 balance;
  final String? walletId;

  const Contact({
    required this.id,
    required this.name,
    this.username,
    this.phone,
    this.email,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
    required this.isSynced,
    required this.balance,
    this.walletId,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      username.hashCode ^
      phone.hashCode ^
      email.hashCode ^
      notes.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      isSynced.hashCode ^
      balance.hashCode ^
      walletId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Contact &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          username == other.username &&
          phone == other.phone &&
          email == other.email &&
          notes == other.notes &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          isSynced == other.isSynced &&
          balance == other.balance &&
          walletId == other.walletId;
}

/// Supported currencies. UI passes the chosen code (e.g. "IQD"); no default in Rust.
enum Currency {
  iqd,
  usd,
  eur,
  gbp,
  jpy,
  chf,
  cad,
  aud,
  cny,
  inr,
  sar,
  aed,
  egp,
  try_,
  brl,
  mxn,
  krw,
  zar,
  rub,
  ;

  Future<void> asStr() => RustLib.instance.api.crateModelsCurrencyAsStr(
        that: this,
      );

  static Future<Currency> default_() =>
      RustLib.instance.api.crateModelsCurrencyDefault();

  static Future<Currency?> fromStr({required String s}) =>
      RustLib.instance.api.crateModelsCurrencyFromStr(s: s);
}

/// Transaction (wire format). Currency is enum; dates/IDs remain string for compatibility.
class Transaction {
  final String id;
  final String contactId;
  final TransactionType type;
  final TransactionDirection direction;
  final PlatformInt64 amount;
  final Currency currency;
  final String? description;
  final String transactionDate;
  final String? dueDate;
  final List<String> imagePaths;
  final String createdAt;
  final String updatedAt;
  final bool isSynced;
  final String? walletId;

  const Transaction({
    required this.id,
    required this.contactId,
    required this.type,
    required this.direction,
    required this.amount,
    required this.currency,
    this.description,
    required this.transactionDate,
    this.dueDate,
    required this.imagePaths,
    required this.createdAt,
    required this.updatedAt,
    required this.isSynced,
    this.walletId,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      contactId.hashCode ^
      type.hashCode ^
      direction.hashCode ^
      amount.hashCode ^
      currency.hashCode ^
      description.hashCode ^
      transactionDate.hashCode ^
      dueDate.hashCode ^
      imagePaths.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      isSynced.hashCode ^
      walletId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Transaction &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          contactId == other.contactId &&
          type == other.type &&
          direction == other.direction &&
          amount == other.amount &&
          currency == other.currency &&
          description == other.description &&
          transactionDate == other.transactionDate &&
          dueDate == other.dueDate &&
          imagePaths == other.imagePaths &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          isSynced == other.isSynced &&
          walletId == other.walletId;
}

enum TransactionDirection {
  owed,
  lent,
  ;
}

enum TransactionType {
  money,
  item,
  ;
}

class Wallet {
  final String id;
  final String name;
  final String? description;
  final String createdAt;
  final String updatedAt;
  final bool isActive;
  final String? createdBy;

  const Wallet({
    required this.id,
    required this.name,
    this.description,
    required this.createdAt,
    required this.updatedAt,
    required this.isActive,
    this.createdBy,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      description.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      isActive.hashCode ^
      createdBy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Wallet &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          description == other.description &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          isActive == other.isActive &&
          createdBy == other.createdBy;
}
