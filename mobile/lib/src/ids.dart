// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `validate_uuid`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `deserialize`, `deserialize`, `deserialize`, `deserialize`, `deserialize`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`, `from_str`, `from_str`, `from_str`, `from_str`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `hash`, `serialize`, `serialize`, `serialize`, `serialize`, `serialize`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `parse`, `parse`, `parse`, `parse`, `parse`

/// Contact ID (UUID). Validated on construction via `parse`/`from_str`. Inner field pub for FFI codegen.
class ContactId {
  final String field0;

  const ContactId({
    required this.field0,
  });

  Future<void> asStr() => RustLib.instance.api.crateIdsContactIdAsStr(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Event ID (UUID). Validated on construction via `parse`/`from_str`. Inner field pub for FFI codegen.
class EventId {
  final String field0;

  const EventId({
    required this.field0,
  });

  Future<void> asStr() => RustLib.instance.api.crateIdsEventIdAsStr(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EventId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Transaction ID (UUID). Validated on construction via `parse`/`from_str`. Inner field pub for FFI codegen.
class TransactionId {
  final String field0;

  const TransactionId({
    required this.field0,
  });

  Future<void> asStr() => RustLib.instance.api.crateIdsTransactionIdAsStr(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// User ID (UUID). Validated on construction via `parse`/`from_str`. Inner field pub for FFI codegen.
class UserId {
  final String field0;

  const UserId({
    required this.field0,
  });

  Future<void> asStr() => RustLib.instance.api.crateIdsUserIdAsStr(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Wallet ID (UUID). Validated on construction via `parse`/`from_str`. Inner field pub for FFI codegen.
class WalletId {
  final String field0;

  const WalletId({
    required this.field0,
  });

  Future<void> asStr() => RustLib.instance.api.crateIdsWalletIdAsStr(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}
