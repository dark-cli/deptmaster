// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_tables`, `with_db`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

Future<void> init({required String path}) =>
    RustLib.instance.api.crateStorageInit(path: path);

Future<String?> configGet({required String key}) =>
    RustLib.instance.api.crateStorageConfigGet(key: key);

Future<void> configSet({required String key, required String value}) =>
    RustLib.instance.api.crateStorageConfigSet(key: key, value: value);

Future<void> configRemove({required String key}) =>
    RustLib.instance.api.crateStorageConfigRemove(key: key);

Future<void> clearAll() => RustLib.instance.api.crateStorageClearAll();

Future<void> eventsInsert({required StoredEvent e}) =>
    RustLib.instance.api.crateStorageEventsInsert(e: e);

/// Update event_data JSON for an event (e.g. to add total_debt after rebuild).
Future<void> eventsUpdateEventData(
        {required String eventId, required String eventDataJson}) =>
    RustLib.instance.api.crateStorageEventsUpdateEventData(
        eventId: eventId, eventDataJson: eventDataJson);

Future<List<StoredEvent>> eventsGetAll({required String walletId}) =>
    RustLib.instance.api.crateStorageEventsGetAll(walletId: walletId);

Future<List<StoredEvent>> eventsGetUnsynced({required String walletId}) =>
    RustLib.instance.api.crateStorageEventsGetUnsynced(walletId: walletId);

Future<void> eventsMarkSynced({required List<String> ids}) =>
    RustLib.instance.api.crateStorageEventsMarkSynced(ids: ids);

/// Delete all unsynced (pending) events for a wallet.
Future<BigInt> eventsDeleteUnsynced({required String walletId}) =>
    RustLib.instance.api.crateStorageEventsDeleteUnsynced(walletId: walletId);

Future<PlatformInt64> eventsCount({required String walletId}) =>
    RustLib.instance.api.crateStorageEventsCount(walletId: walletId);

/// Get all events for an aggregate, sorted by timestamp ascending (oldest first).
Future<List<StoredEvent>> eventsGetForAggregate(
        {required String walletId,
        required String aggregateType,
        required String aggregateId}) =>
    RustLib.instance.api.crateStorageEventsGetForAggregate(
        walletId: walletId,
        aggregateType: aggregateType,
        aggregateId: aggregateId);

Future<void> stateSave(
        {required String walletId,
        required List<Contact> contacts,
        required List<Transaction> transactions}) =>
    RustLib.instance.api.crateStorageStateSave(
        walletId: walletId, contacts: contacts, transactions: transactions);

Future<(List<Contact>, List<Transaction>)?> stateLoad(
        {required String walletId}) =>
    RustLib.instance.api.crateStorageStateLoad(walletId: walletId);

class StoredEvent {
  final String id;
  final String walletId;
  final String aggregateType;
  final String aggregateId;
  final String eventType;
  final String eventData;
  final String timestamp;
  final int version;
  final bool synced;

  const StoredEvent({
    required this.id,
    required this.walletId,
    required this.aggregateType,
    required this.aggregateId,
    required this.eventType,
    required this.eventData,
    required this.timestamp,
    required this.version,
    required this.synced,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      walletId.hashCode ^
      aggregateType.hashCode ^
      aggregateId.hashCode ^
      eventType.hashCode ^
      eventData.hashCode ^
      timestamp.hashCode ^
      version.hashCode ^
      synced.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StoredEvent &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          walletId == other.walletId &&
          aggregateType == other.aggregateType &&
          aggregateId == other.aggregateId &&
          eventType == other.eventType &&
          eventData == other.eventData &&
          timestamp == other.timestamp &&
          version == other.version &&
          synced == other.synced;
}
