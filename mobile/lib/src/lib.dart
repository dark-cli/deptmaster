// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BackendConfig`

/// Call once at startup with the app documents directory path (e.g. from path_provider).
Future<void> initStorage({required String storagePath}) =>
    RustLib.instance.api.crateInitStorage(storagePath: storagePath);

Future<void> setBackendConfig(
        {required String baseUrl, required String wsUrl}) =>
    RustLib.instance.api.crateSetBackendConfig(baseUrl: baseUrl, wsUrl: wsUrl);

Future<String?> getBaseUrl() => RustLib.instance.api.crateGetBaseUrl();

Future<String?> getWsUrl() => RustLib.instance.api.crateGetWsUrl();

Future<void> login({required String username, required String password}) =>
    RustLib.instance.api.crateLogin(username: username, password: password);

Future<void> logout() => RustLib.instance.api.crateLogout();

Future<bool> isLoggedIn() => RustLib.instance.api.crateIsLoggedIn();

Future<String?> getUserId() => RustLib.instance.api.crateGetUserId();

Future<String?> getToken() => RustLib.instance.api.crateGetToken();

Future<void> setCurrentWalletId({required String walletId}) =>
    RustLib.instance.api.crateSetCurrentWalletId(walletId: walletId);

Future<String?> getCurrentWalletId() =>
    RustLib.instance.api.crateGetCurrentWalletId();

Future<String> getWallets() => RustLib.instance.api.crateGetWallets();

Future<String> createWallet(
        {required String name, required String description}) =>
    RustLib.instance.api
        .crateCreateWallet(name: name, description: description);

Future<void> ensureCurrentWallet() =>
    RustLib.instance.api.crateEnsureCurrentWallet();

Future<String> getContacts() => RustLib.instance.api.crateGetContacts();

Future<String> getTransactions() => RustLib.instance.api.crateGetTransactions();

Future<String?> getContact({required String id}) =>
    RustLib.instance.api.crateGetContact(id: id);

Future<String> createContact(
        {required String name,
        String? username,
        String? phone,
        String? email,
        String? notes}) =>
    RustLib.instance.api.crateCreateContact(
        name: name,
        username: username,
        phone: phone,
        email: email,
        notes: notes);

Future<String> createTransaction(
        {required String contactId,
        required String type,
        required String direction,
        required PlatformInt64 amount,
        required String currency,
        String? description,
        required String transactionDate,
        String? dueDate}) =>
    RustLib.instance.api.crateCreateTransaction(
        contactId: contactId,
        type: type,
        direction: direction,
        amount: amount,
        currency: currency,
        description: description,
        transactionDate: transactionDate,
        dueDate: dueDate);

Future<String?> getTransaction({required String id}) =>
    RustLib.instance.api.crateGetTransaction(id: id);

Future<void> updateContact(
        {required String id,
        required String name,
        String? username,
        String? phone,
        String? email,
        String? notes}) =>
    RustLib.instance.api.crateUpdateContact(
        id: id,
        name: name,
        username: username,
        phone: phone,
        email: email,
        notes: notes);

Future<void> deleteContact({required String contactId}) =>
    RustLib.instance.api.crateDeleteContact(contactId: contactId);

Future<void> updateTransaction(
        {required String id,
        required String contactId,
        required String type,
        required String direction,
        required PlatformInt64 amount,
        required String currency,
        String? description,
        required String transactionDate,
        String? dueDate}) =>
    RustLib.instance.api.crateUpdateTransaction(
        id: id,
        contactId: contactId,
        type: type,
        direction: direction,
        amount: amount,
        currency: currency,
        description: description,
        transactionDate: transactionDate,
        dueDate: dueDate);

Future<void> deleteTransaction({required String transactionId}) =>
    RustLib.instance.api.crateDeleteTransaction(transactionId: transactionId);

Future<void> undoContactAction({required String contactId}) =>
    RustLib.instance.api.crateUndoContactAction(contactId: contactId);

Future<void> undoTransactionAction({required String transactionId}) =>
    RustLib.instance.api
        .crateUndoTransactionAction(transactionId: transactionId);

Future<void> bulkDeleteContacts({required List<String> contactIds}) =>
    RustLib.instance.api.crateBulkDeleteContacts(contactIds: contactIds);

Future<void> bulkDeleteTransactions({required List<String> transactionIds}) =>
    RustLib.instance.api
        .crateBulkDeleteTransactions(transactionIds: transactionIds);

Future<String> getEvents() => RustLib.instance.api.crateGetEvents();

Future<void> manualSync() => RustLib.instance.api.crateManualSync();

/// Drain buffered Rust log lines so Dart can show them (e.g. via debugPrint).
Future<List<String>> drainRustLogs() =>
    RustLib.instance.api.crateDrainRustLogs();

Future<String> greet({required String name}) =>
    RustLib.instance.api.crateGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Value>>
abstract class Value implements RustOpaqueInterface {}
