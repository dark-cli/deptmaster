// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `is_network_error`, `is_rate_limited`, `jwt_payload`, `manual_sync_with_source`, `should_log_skip`, `start_sync_loop_if_ready`, `try_acquire`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BackendConfig`, `SyncGuard`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `drop`

/// Call once at startup with the app documents directory path (e.g. from path_provider).
/// Storage is process-wide; no need to call again from every thread.
Future<void> initStorage({required String storagePath}) =>
    RustLib.instance.api.crateInitStorage(storagePath: storagePath);

Future<void> setBackendConfig(
        {required String baseUrl, required String wsUrl}) =>
    RustLib.instance.api.crateSetBackendConfig(baseUrl: baseUrl, wsUrl: wsUrl);

Future<String?> getBaseUrl() => RustLib.instance.api.crateGetBaseUrl();

Future<String?> getWsUrl() => RustLib.instance.api.crateGetWsUrl();

/// Set whether the client is in "offline" mode. When true, all API requests return an error without hitting the network.
/// The app reconnects WS when going online; WS connection triggers sync (app logic, not here).
/// Thread-local (per test / per app when using multiple instances).
Future<void> setNetworkOffline({required bool offline}) =>
    RustLib.instance.api.crateSetNetworkOffline(offline: offline);

/// True if the client is in offline mode (network requests will fail).
Future<bool> isNetworkOffline() => RustLib.instance.api.crateIsNetworkOffline();

Future<void> login({required String username, required String password}) =>
    RustLib.instance.api.crateLogin(username: username, password: password);

Future<void> register({required String username, required String password}) =>
    RustLib.instance.api.crateRegister(username: username, password: password);

Future<void> logout() => RustLib.instance.api.crateLogout();

Future<bool> isLoggedIn() => RustLib.instance.api.crateIsLoggedIn();

Future<String?> getUserId() => RustLib.instance.api.crateGetUserId();

Future<String?> getToken() => RustLib.instance.api.crateGetToken();

Future<void> setCurrentWalletId({required String walletId}) =>
    RustLib.instance.api.crateSetCurrentWalletId(walletId: walletId);

Future<String?> getCurrentWalletId() =>
    RustLib.instance.api.crateGetCurrentWalletId();

Future<String> getWallets() => RustLib.instance.api.crateGetWallets();

Future<String> createWallet(
        {required String name, required String description}) =>
    RustLib.instance.api
        .crateCreateWallet(name: name, description: description);

Future<void> ensureCurrentWallet() =>
    RustLib.instance.api.crateEnsureCurrentWallet();

Future<String> getContacts() => RustLib.instance.api.crateGetContacts();

Future<String> getTransactions() => RustLib.instance.api.crateGetTransactions();

Future<String?> getContact({required String id}) =>
    RustLib.instance.api.crateGetContact(id: id);

Future<String> createContact(
        {required String name,
        String? username,
        String? phone,
        String? email,
        String? notes}) =>
    RustLib.instance.api.crateCreateContact(
        name: name,
        username: username,
        phone: phone,
        email: email,
        notes: notes);

Future<String> createTransaction(
        {required String contactId,
        required String type,
        required String direction,
        required PlatformInt64 amount,
        required String currency,
        String? description,
        required String transactionDate,
        String? dueDate}) =>
    RustLib.instance.api.crateCreateTransaction(
        contactId: contactId,
        type: type,
        direction: direction,
        amount: amount,
        currency: currency,
        description: description,
        transactionDate: transactionDate,
        dueDate: dueDate);

Future<String?> getTransaction({required String id}) =>
    RustLib.instance.api.crateGetTransaction(id: id);

Future<void> updateContact(
        {required String id,
        required String name,
        String? username,
        String? phone,
        String? email,
        String? notes}) =>
    RustLib.instance.api.crateUpdateContact(
        id: id,
        name: name,
        username: username,
        phone: phone,
        email: email,
        notes: notes);

Future<void> deleteContact({required String contactId}) =>
    RustLib.instance.api.crateDeleteContact(contactId: contactId);

Future<void> updateTransaction(
        {required String id,
        required String contactId,
        required String type,
        required String direction,
        required PlatformInt64 amount,
        required String currency,
        String? description,
        required String transactionDate,
        String? dueDate}) =>
    RustLib.instance.api.crateUpdateTransaction(
        id: id,
        contactId: contactId,
        type: type,
        direction: direction,
        amount: amount,
        currency: currency,
        description: description,
        transactionDate: transactionDate,
        dueDate: dueDate);

Future<void> deleteTransaction({required String transactionId}) =>
    RustLib.instance.api.crateDeleteTransaction(transactionId: transactionId);

Future<void> undoContactAction({required String contactId}) =>
    RustLib.instance.api.crateUndoContactAction(contactId: contactId);

Future<void> undoTransactionAction({required String transactionId}) =>
    RustLib.instance.api
        .crateUndoTransactionAction(transactionId: transactionId);

Future<void> bulkDeleteContacts({required List<String> contactIds}) =>
    RustLib.instance.api.crateBulkDeleteContacts(contactIds: contactIds);

Future<void> bulkDeleteTransactions({required List<String> transactionIds}) =>
    RustLib.instance.api
        .crateBulkDeleteTransactions(transactionIds: transactionIds);

Future<String> listWalletUsers({required String walletId}) =>
    RustLib.instance.api.crateListWalletUsers(walletId: walletId);

Future<String> searchWalletUsers(
        {required String walletId, required String query}) =>
    RustLib.instance.api
        .crateSearchWalletUsers(walletId: walletId, query: query);

Future<void> addUserToWallet(
        {required String walletId, required String username}) =>
    RustLib.instance.api
        .crateAddUserToWallet(walletId: walletId, username: username);

/// Create or replace 4-digit invite code for the wallet. Returns the code string.
Future<String> createWalletInviteCode({required String walletId}) =>
    RustLib.instance.api.crateCreateWalletInviteCode(walletId: walletId);

/// Join a wallet by invite code. Returns the wallet_id of the joined wallet.
Future<String> joinWalletByCode({required String code}) =>
    RustLib.instance.api.crateJoinWalletByCode(code: code);

Future<void> updateWalletUserRole(
        {required String walletId,
        required String userId,
        required String role}) =>
    RustLib.instance.api.crateUpdateWalletUserRole(
        walletId: walletId, userId: userId, role: role);

Future<void> removeWalletUser(
        {required String walletId, required String userId}) =>
    RustLib.instance.api
        .crateRemoveWalletUser(walletId: walletId, userId: userId);

Future<String> listWalletUserGroups({required String walletId}) =>
    RustLib.instance.api.crateListWalletUserGroups(walletId: walletId);

Future<String> createWalletUserGroup(
        {required String walletId, required String name}) =>
    RustLib.instance.api
        .crateCreateWalletUserGroup(walletId: walletId, name: name);

Future<void> updateWalletUserGroup(
        {required String walletId,
        required String groupId,
        required String name}) =>
    RustLib.instance.api.crateUpdateWalletUserGroup(
        walletId: walletId, groupId: groupId, name: name);

Future<void> deleteWalletUserGroup(
        {required String walletId, required String groupId}) =>
    RustLib.instance.api
        .crateDeleteWalletUserGroup(walletId: walletId, groupId: groupId);

Future<String> listWalletUserGroupMembers(
        {required String walletId, required String groupId}) =>
    RustLib.instance.api
        .crateListWalletUserGroupMembers(walletId: walletId, groupId: groupId);

Future<void> addWalletUserGroupMember(
        {required String walletId,
        required String groupId,
        required String userId}) =>
    RustLib.instance.api.crateAddWalletUserGroupMember(
        walletId: walletId, groupId: groupId, userId: userId);

Future<void> removeWalletUserGroupMember(
        {required String walletId,
        required String groupId,
        required String userId}) =>
    RustLib.instance.api.crateRemoveWalletUserGroupMember(
        walletId: walletId, groupId: groupId, userId: userId);

Future<String> listWalletContactGroups({required String walletId}) =>
    RustLib.instance.api.crateListWalletContactGroups(walletId: walletId);

Future<String> createWalletContactGroup(
        {required String walletId, required String name}) =>
    RustLib.instance.api
        .crateCreateWalletContactGroup(walletId: walletId, name: name);

Future<void> updateWalletContactGroup(
        {required String walletId,
        required String groupId,
        required String name}) =>
    RustLib.instance.api.crateUpdateWalletContactGroup(
        walletId: walletId, groupId: groupId, name: name);

Future<void> deleteWalletContactGroup(
        {required String walletId, required String groupId}) =>
    RustLib.instance.api
        .crateDeleteWalletContactGroup(walletId: walletId, groupId: groupId);

Future<String> listWalletContactGroupMembers(
        {required String walletId, required String groupId}) =>
    RustLib.instance.api.crateListWalletContactGroupMembers(
        walletId: walletId, groupId: groupId);

Future<void> addWalletContactGroupMember(
        {required String walletId,
        required String groupId,
        required String contactId}) =>
    RustLib.instance.api.crateAddWalletContactGroupMember(
        walletId: walletId, groupId: groupId, contactId: contactId);

Future<void> removeWalletContactGroupMember(
        {required String walletId,
        required String groupId,
        required String contactId}) =>
    RustLib.instance.api.crateRemoveWalletContactGroupMember(
        walletId: walletId, groupId: groupId, contactId: contactId);

Future<String> listWalletPermissionActions({required String walletId}) =>
    RustLib.instance.api.crateListWalletPermissionActions(walletId: walletId);

Future<String> getMyPermissions({required String walletId}) =>
    RustLib.instance.api.crateGetMyPermissions(walletId: walletId);

Future<void> clearWalletData({required String walletId}) =>
    RustLib.instance.api.crateClearWalletData(walletId: walletId);

Future<String> getWalletPermissionMatrix({required String walletId}) =>
    RustLib.instance.api.crateGetWalletPermissionMatrix(walletId: walletId);

Future<void> putWalletPermissionMatrix(
        {required String walletId, required String entriesJson}) =>
    RustLib.instance.api.cratePutWalletPermissionMatrix(
        walletId: walletId, entriesJson: entriesJson);

Future<String> getEvents() => RustLib.instance.api.crateGetEvents();

/// Sync with server. If server responds with DEBITUM_AUTH_DECLINED, Rust clears session (logout) and returns that error; Dart only needs to react (e.g. show login).
Future<void> manualSync() => RustLib.instance.api.crateManualSync();

/// Drain buffered Rust log lines so Dart can show them (e.g. via debugPrint).
Future<List<String>> drainRustLogs() =>
    RustLib.instance.api.crateDrainRustLogs();

Future<String?> getPreference({required String key}) =>
    RustLib.instance.api.crateGetPreference(key: key);

Future<void> setPreference({required String key, required String value}) =>
    RustLib.instance.api.crateSetPreference(key: key, value: value);

Future<String?> getUsername() => RustLib.instance.api.crateGetUsername();

/// True if JWT is expired or invalid. Used to avoid WebSocket 401 spam.
Future<bool> isTokenExpired() => RustLib.instance.api.crateIsTokenExpired();

Future<String> greet({required String name}) =>
    RustLib.instance.api.crateGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Value>>
abstract class Value implements RustOpaqueInterface {}

class JwtPayload {
  final String? username;
  final bool expired;

  const JwtPayload({
    this.username,
    required this.expired,
  });

  static Future<JwtPayload> default_() =>
      RustLib.instance.api.crateJwtPayloadDefault();

  @override
  int get hashCode => username.hashCode ^ expired.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is JwtPayload &&
          runtimeType == other.runtimeType &&
          username == other.username &&
          expired == other.expired;
}
