@@
-import 'dart:async';
-import 'dart:convert';
-import 'package:flutter/foundation.dart' show kIsWeb;
-import 'package:web_socket_channel/web_socket_channel.dart';
-import 'api_service.dart';
-import 'backend_config_service.dart';
-import 'sync_service_v2.dart';
-import 'state_builder.dart';
-import 'event_store_service.dart';
-import 'connection_manager.dart';
-import 'connection_state_tracker.dart';
+import 'dart:async';
+import 'dart:convert';
+import 'package:flutter/foundation.dart' show kIsWeb;
+import 'package:web_socket_channel/web_socket_channel.dart';
+import 'api_service.dart';
+import 'backend_config_service.dart';
+import 'sync_service_v2.dart';
+import 'state_builder.dart';
+import 'event_store_service.dart';
+import 'connection_manager.dart';
+import 'connection_state_tracker.dart';
+import 'auth_service.dart';
@@
   static Future<void> connect() async {
-    if (_isConnected && _channel != null) {
-      return;
-    }
-
-    // Wrap entire connection in try-catch to catch all exceptions
-    try {
-      final wsUrl = await _wsUrl;
-      
-      // Create channel - WebSocketChannel.connect() throws asynchronously
-      // The PlatformDispatcher.onError in main.dart will catch and suppress it
-      WebSocketChannel? channel;
-      try {
-        channel = WebSocketChannel.connect(Uri.parse(wsUrl));
-      } catch (e) {
-        // Synchronous error - handle gracefully without crashing
-        print('WebSocket connection error (sync): $e');
-        if (_isConnected) {
-          ConnectionStateTracker.logStateChange(false);
-          _isConnected = false;
-        }
-        _reconnect();
-        return;
-      }
+    // If we are already connected, don't reconnect.
+    if (_isConnected && _channel != null) {
+      return;
+    }
+
+    // Only attempt WebSocket connection if the user is logged in (has a token)
+    final token = await AuthService.getToken();
+    if (token == null || token.isEmpty) {
+      // No auth token -> don't spam the server with unauthorized WebSocket attempts
+      _isConnected = false;
+      _channel = null;
+      _subscription = null;
+      return;
+    }
+
+    // Wrap entire connection in try-catch to catch all exceptions
+    try {
+      final wsUrl = await _wsUrl;
+      
+      // Create channel - WebSocketChannel.connect() throws asynchronously
+      // The PlatformDispatcher.onError in main.dart will catch and suppress it
+      WebSocketChannel? channel;
+      try {
+        // Include JWT token in Authorization header so backend can authenticate /ws
+        channel = WebSocketChannel.connect(
+          Uri.parse(wsUrl),
+          headers: {
+            'Authorization': 'Bearer $token',
+          },
+        );
+      } catch (e) {
+        // Synchronous error - handle gracefully without crashing
+        print('WebSocket connection error (sync): $e');
+        if (_isConnected) {
+          ConnectionStateTracker.logStateChange(false);
+          _isConnected = false;
+        }
+        _reconnect();
+        return;
+      }
